"""
FinLab MCP Server for Cloudflare Workers

Auto-generated by build.py - DO NOT EDIT MANUALLY
Documentation is embedded from finlab-plugin/skills/finlab/*.md
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("finlab-docs")

# Embedded documentation (auto-generated from finlab-plugin/skills/finlab/*.md)
DOCS: dict[str, str] = {
  "backtesting-reference": "# Backtesting Reference\n\n## Overview\n\nThe FinLab backtesting framework allows you to simulate trading strategies using historical data. The `backtest.sim()` function is the core tool for evaluating strategy performance, supporting various parameters for rebalancing, transaction costs, stop-loss/take-profit, and more.\n\n---\n\n## backtest.sim\n\nSimulate the equity curve of a stock portfolio based on its position history and market data. This function supports various parameters for rebalancing frequency, transaction costs, stop loss/take profit, and notification via Line.\n\n**Import:**\n```python\nfrom finlab import backtest\n```\n\n**Signature:**\n```python\nsim(\n    position: Union[pd.DataFrame, pd.Series],\n    resample: Union[str, None] = None,\n    resample_offset: Union[str, None] = None,\n    trade_at_price: Union[str, pd.DataFrame] = 'close',\n    position_limit: float = 1,\n    fee_ratio: float = 1.425/1000,\n    tax_ratio: float = 3/1000,\n    name: str = '未命名',\n    stop_loss: Union[float, None] = None,\n    take_profit: Union[float, None] = None,\n    trail_stop: Union[float, None] = None,\n    touched_exit: bool = False,\n    retain_cost_when_rebalance: bool = False,\n    stop_trading_next_period: bool = True,\n    live_performance_start: Union[str, None] = None,\n    mae_mfe_window: int = 0,\n    mae_mfe_window_step: int = 1,\n    market: Union[None, Market] = None,\n    upload: bool = True,\n    fast_mode: bool = False,\n    notification_enable: bool = False,\n    line_access_token: str = ''\n) -> report.Report\n```\n\n### Parameters\n\n#### position\n- **Type:** `Union[pd.DataFrame, pd.Series]`\n- **Required:** Yes\n- **Description:** A pandas DataFrame or Series representing the buy/sell signals (True indicates holding, False indicates no position). For short positions, negative values can be used. The index should be a DatetimeIndex, and the columns should represent stock IDs.\n\n#### resample\n- **Type:** `Union[str, None]`\n- **Default:** `None`\n- **Description:** Trading frequency or rebalancing dates specification. It can be a string (e.g., 'D', 'W', 'M'), a DataFrame, Series, or None. When None, rebalancing only occurs on changes in the position.\n\n#### resample_offset\n- **Type:** `Union[str, None]`\n- **Default:** `None`\n- **Description:** An optional time offset (e.g., '1D', '1H') applied to rebalance dates.\n\n#### trade_at_price\n- **Type:** `Union[str, pd.DataFrame]`\n- **Default:** `'close'`\n- **Description:** Specifies which market price to use in the simulation. Options include 'close', 'open', 'open_close_avg', 'high_low_avg', or a custom DataFrame with price data.\n\n#### position_limit\n- **Type:** `float`\n- **Default:** `1`\n- **Description:** Limit for the maximum weight assigned to any single asset (e.g., 0.2 for 20%).\n\n#### fee_ratio\n- **Type:** `float`\n- **Default:** `1.425/1000`\n- **Description:** Commission fee ratio applied during trades.\n\n#### tax_ratio\n- **Type:** `float`\n- **Default:** `3/1000`\n- **Description:** Transaction tax ratio applied when selling stocks.\n\n#### name\n- **Type:** `str`\n- **Default:** `'未命名'`\n- **Description:** Name for the strategy (for reporting purposes).\n\n#### stop_loss\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Stop loss percentage threshold. If set to None, stop loss is disabled.\n\n#### take_profit\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Take profit percentage threshold. If set to None, take profit is disabled.\n\n#### trail_stop\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Trailing stop threshold. If set to None, trailing stop is disabled.\n\n#### touched_exit\n- **Type:** `bool`\n- **Default:** `False`\n- **Description:** Flag to enable price touch exit logic. Use with caution as it may affect candle details.\n\n#### retain_cost_when_rebalance\n- **Type:** `bool`\n- **Default:** `False`\n- **Description:** Whether to carry forward the original cost basis when rebalancing positions.\n\n#### stop_trading_next_period\n- **Type:** `bool`\n- **Default:** `True`\n- **Description:** If a stop loss/take profit event occurs, trading is suspended for the next period.\n\n#### mae_mfe_window\n- **Type:** `int`\n- **Default:** `0`\n- **Description:** Window length for calculating maximum adverse excursion (MAE) and maximum favorable excursion (MFE).\n\n#### mae_mfe_window_step\n- **Type:** `int`\n- **Default:** `1`\n- **Description:** Step interval for the MAE/MFE analysis.\n\n#### upload\n- **Type:** `bool`\n- **Default:** `True`\n- **Description:** Determines whether to upload the strategy performance report after simulation.\n\n### Returns\n\nAn instance of `Report` containing performance metrics, trades, and additional analyses.\n\n---\n\n## Report Class Reference\n\nThe `sim()` function returns a `Report` object with multiple APIs for accessing performance metrics.\n\n### Method 1: `report.metrics` (Recommended for single metrics)\n\nAccess individual metrics via the `Metrics` instance:\n\n```python\nreport = sim(position, resample=\"M\", upload=False)\n\n# Individual metric methods\nprint(f\"Annual Return: {report.metrics.annual_return():.2%}\")\nprint(f\"Sharpe Ratio: {report.metrics.sharpe_ratio():.2f}\")\nprint(f\"Max Drawdown: {report.metrics.max_drawdown():.2%}\")\n```\n\n### Method 2: `report.get_stats()` (Returns dictionary)\n\nReturns a flat dictionary with all stats. Useful for batch access:\n\n```python\nstats = report.get_stats()\n\n# Dictionary keys (note: different names than metrics methods!)\nprint(f\"Annual Return: {stats['cagr']:.2%}\")\nprint(f\"Sharpe Ratio: {stats['monthly_sharpe']:.2f}\")\nprint(f\"Max Drawdown: {stats['max_drawdown']:.2%}\")\nprint(f\"Win Ratio: {stats['win_ratio']:.2%}\")\nprint(f\"Total Return: {stats['total_return']:.2%}\")\n```\n\n**Available keys in `get_stats()`:**\n- `cagr` - Compound Annual Growth Rate\n- `daily_sharpe` - Daily Sharpe ratio\n- `monthly_sharpe` - Monthly Sharpe ratio\n- `max_drawdown` - Maximum drawdown (negative value)\n- `win_ratio` - Win rate of trades\n- `total_return` - Total cumulative return\n- `start` - Backtest start date (string)\n- `end` - Backtest end date (string)\n- `return_table` - Dict of monthly returns by year\n\n### Method 3: `report.get_metrics()` (Structured nested dictionary)\n\nReturns a nested dictionary organized by category:\n\n```python\nmetrics = report.get_metrics()\n\n# Structured access\nprint(metrics['profitability']['annualReturn'])\nprint(metrics['ratio']['sharpeRatio'])\nprint(metrics['risk']['maxDrawdown'])\n```\n\n**Categories:**\n- `backtest` - startDate, endDate, feeRatio, taxRatio, market, freq\n- `profitability` - annualReturn, alpha, beta, avgNStock, maxNStock\n- `risk` - maxDrawdown, avgDrawdown, avgDrawdownDays, valueAtRisk\n- `ratio` - sharpeRatio, sortinoRatio, calmarRatio, volatility\n- `winrate` - winRate, m12WinRate, expectancy, mae, mfe\n- `liquidity` - capacity, disposalStockRatio, warningStockRatio\n\n### Other Useful Methods\n\n```python\n# Display interactive report\nreport.display()\n\n# Get trade details\ntrades_df = report.get_trades()\n\n# Save to file\nreport.to_html(\"report.html\")\nreport.to_pickle(\"report.pkl\")\n\n# Load from file\nloaded_report = Report.from_pickle(\"report.pkl\")\n\n# Run specific analysis\nreport.run_analysis(\"Drawdown\")\nreport.run_analysis(\"MaeMfe\")\n```\n\n### Key Attribute Mappings\n\n| Desired Metric | `report.metrics.X()` | `report.get_stats()['X']` |\n|----------------|----------------------|---------------------------|\n| Annual Return | `annual_return()` | `'cagr'` |\n| Sharpe Ratio | `sharpe_ratio()` | `'monthly_sharpe'` |\n| Max Drawdown | `max_drawdown()` | `'max_drawdown'` |\n| Win Rate | `win_rate()` | `'win_ratio'` |\n| Total Return | - | `'total_return'` |\n\n---\n\n## Example Usage\n\n### Basic Example\n\n```python\nimport pandas as pd\nfrom finlab import backtest\n\n# Example position DataFrame with dates as index\nposition = pd.DataFrame({\n    '2330': [0, 1, 1],\n    '1101': [0.2, 0, 0],\n    '2454': [0.4, 0, 0]\n}, index=pd.to_datetime(['2021-12-31', '2022-03-31', '2022-06-30']))\n\nreport = backtest.sim(position)\nprint(report)\n```\n\n### Advanced Example with Stop Loss and Take Profit\n\n```python\nfrom finlab import data, backtest\n\nclose = data.get('price:收盤價')\npb = data.get('price_earning_ratio:股價淨值比')\n\n# Define entry and exit conditions\nentries = close > close.average(20)\nexits = close < close.average(60)\n\n# Create position with ranking\nposition = entries.hold_until(exits, nstocks_limit=10, rank=-pb)\n\n# Backtest with stop loss and take profit\nreport = backtest.sim(\n    position,\n    resample='M',\n    stop_loss=0.1,      # 10% stop loss\n    take_profit=0.2,    # 20% take profit\n    name='MA Strategy with SL/TP'\n)\n\n# Display metrics\nprint(report.get_metrics())\n```\n\n---\n\n## Strategy Development Workflow\n\n### Step 1: Fetching Data\n\nGather the necessary data using `data.get()`, including historical prices, volume, and any relevant indicators.\n\n**Important Notes:**\n- Use `with data.universe(...)` ONLY to scope `data.get(...)` calls; do NOT wrap position DataFrame operations\n- When specifying category/exclude_category, use industry names only (no numeric codes like '28')\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue = data.get('monthly_revenue:當月營收')\n```\n\n---\n\n### Step 2: Factor Creation\n\nCreate factors or indicators that will be used in your strategy.\n\n**Available Methods:**\n- `average`, `rolling(n).mean`, `rolling(n).std`, `rolling(n).max`, `rolling(n).min`\n- `is_largest`, `is_smallest`\n- `sustain`, `rise`, `fall`\n- `industry_rank`, `quantile_row`\n- Arithmetic operators: `+`, `-`, `*`, `/`\n- Comparison operators: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical operators: `&`, `|`, `~`\n\n**Important Notes:**\n- Do not use `==` for floating point comparisons. Use `np.isclose()` instead\n- Be cautious with `&` and `|` operators; ensure proper parentheses to avoid precedence issues\n- Prevent using reindex to align FinlabDataFrame as it already has aligned indices and columns\n- Do not use for loops to iterate over rows or columns. Use vectorized operations instead\n\n**Example:**\n```python\n# Calculate moving averages\nsma20 = close.average(20)\nsma60 = close.average(60)\n\n# Revenue growth\nrev_growth = revenue.pct_change(12)\n\n# Combine multiple conditions\nstrong_momentum = (close > sma20) & (close > sma60)\n```\n\n---\n\n### Step 3: Construct Position\n\nDefine the DataFrame structure for your trading positions. The index should be a DatetimeIndex, and the columns should represent stock IDs. Use boolean values to indicate whether to hold or not, or numeric values for position sizes.\n\n**Important Notes:**\n- If user does not mention the sell condition, you can just use `position = a & b & c`\n- Without sell condition, the position will be held until the end of the resample period, which is recommended, since we can set stop loss or take profit in the sim function\n- If user mentions the sell condition, it is recommended to use `position = buy.hold_until(sell)` where buy is `(a & b & c)` and sell is `(a | b | c)`\n- Use `&` and `|` to combine multiple conditions, and use parentheses to ensure correct precedence\n- DO NOT use for loop to iterate over rows or columns. FinlabDataFrame already has aligned indices and columns for you\n\n**Example:**\n```python\n# Simple position without explicit sell condition\nposition = (close > sma20) & (rev_growth > 0.1)\n\n# Position with entry and exit signals\nbuy = (close > sma20) & (volume > volume.average(20))\nsell = (close < sma60) | (rev_growth < 0)\nposition = buy.hold_until(sell, nstocks_limit=10)\n```\n\n---\n\n### Step 4: Backtest the Strategy\n\nTest your strategy's performance and make adjustments as needed.\n\n**Associated Methods:**\n- `backtest.sim`\n- `report.display`\n- `report.get_metrics`\n\n**Important Notes:**\n- Use the `sim` function to simulate performance based on your position DataFrame\n- If monthly revenue is used (as variable `rev`), please set `resample` to `rev.index`\n- If user not mention, please set `resample` to 'ME' or 'Q' to avoid overtrading\n- Use `print(report.get_metrics())` to extract performance metrics\n- If scoping tradable universe at simulation time, you may wrap the backtest call with `with data.universe(...)` — but NEVER wrap factor/position calculations inside that context\n\n**Example:**\n```python\nfrom finlab import backtest\n\n# Simple backtest\nreport = backtest.sim(position, resample='M')\n\n# Backtest with universe filtering\nwith data.universe(market='TSE_OTC', exclude_category='金融'):\n    report = backtest.sim(position, resample='Q')\n\n# Display metrics\nprint(report.get_metrics())\nreport.display()\n```\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Learn about enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Explore available data sources\n- [Factor Examples](factor-examples.md) - See complete strategy examples\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n",
  "best-practices": "# FinLab Best Practices and Anti-Patterns\n\nThis document contains critical coding patterns, anti-patterns, and best practices for developing FinLab strategies. **Following these guidelines prevents common errors, lookahead bias, and data pollution.**\n\n## Table of Contents\n\n1. [Code Patterns (DO THIS)](#code-patterns-do-this)\n2. [Anti-Patterns (DON'T DO THIS)](#anti-patterns-dont-do-this)\n3. [Preventing Future Data Pollution](#preventing-future-data-pollution)\n4. [Stock Selection Patterns](#stock-selection-patterns)\n5. [Backtesting Patterns](#backtesting-patterns)\n6. [Error Handling](#error-handling)\n\n---\n\n## Code Patterns (DO THIS)\n\n### ✅ Combine Conditions with Logical Operators\n\n**DO:** Use `&`, `|`, `~` to combine conditions into a single position DataFrame.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nfactor1 = data.get(\"price:收盤價\")\nfactor2 = data.get(\"monthly_revenue:當月營收\")\nfactor3 = data.get(\"price_earning_ratio:本益比\")\n\ncond1 = factor1.rank(axis=1, pct=True) > 0.5\ncond2 = factor2.rank(axis=1, pct=True) > 0.5\n\ncond_intersection = cond1 & cond2\nposition = factor3[cond_intersection].is_smallest(5)\n\nreport = sim(position, resample=\"M\")\n```\n\n**DON'T:** Create separate functions to generate positions (adds unnecessary complexity).\n\n### ✅ Use `is_smallest()` or `is_largest()` for Stock Selection\n\n**DO:** Limit to top N < 50 stocks using these methods.\n\n```python\n# Select top 10 stocks by lowest P/E\npe = data.get(\"price_earning_ratio:本益比\")\nposition = pe.is_smallest(10)\n\n# Select top 15 stocks by highest momentum, where condition is met\nclose = data.get(\"price:收盤價\")\nmomentum = close / close.shift(20) - 1\ncondition = close > close.average(60)\nposition = momentum[condition].is_largest(15)\n```\n\n**Note:** The DataFrame used with `is_smallest()`/`is_largest()` must have **float dtype**, not bool. If you have a boolean condition, apply it as a filter first.\n\n### ✅ Use Correct Technical Indicator Syntax\n\n**DO:** Call `data.indicator()` without passing OHLCV data.\n\n```python\n# Correct - no OHLCV parameters\nrsi = data.indicator(\"RSI\", timeperiod=14)\n\n# Correct - multiple return values\nmacd, macd_signal, macd_hist = data.indicator(\n    \"MACD\",\n    fastperiod=12,\n    slowperiod=26,\n    signalperiod=9\n)\n\n# Correct - Bollinger Bands\nupperband, middleband, lowerband = data.indicator(\n    \"BBANDS\",\n    timeperiod=20,\n    nbdevup=2.0,\n    nbdevdn=2.0,\n    matype=0\n)\n```\n\n**DON'T:** Pass close price or OHLCV data to indicators.\n\n```python\n# ❌ WRONG - don't pass close\nrsi = data.indicator(\"RSI\", close, timeperiod=14)  # ERROR\n```\n\n### ✅ Use `df.shift(1)` for Previous Values\n\n**DO:** Use `.shift()` to access historical data.\n\n```python\n# Correct - get previous day's close\nprev_close = close.shift(1)\n\n# Correct - detect crossover\nsma20 = close.average(20)\nsma60 = close.average(60)\ngolden_cross = (sma20 > sma60) & (sma20.shift() < sma60.shift())\n```\n\n**DON'T:** Use `.iloc[-2]` or similar indexing (can cause lookahead bias).\n\n```python\n# ❌ WRONG\nprev_close = close.iloc[-2]  # DON'T USE THIS\n```\n\n### ✅ Use `data.universe()` for Filtering\n\n**DO:** Use context manager or `set_universe()` to filter stocks by market/category.\n\n```python\nfrom finlab import data\n\n# Method 1: Context manager (temporary scope)\nwith data.universe(market='TSE_OTC', category=['水泥工業']):\n    price = data.get('price:收盤價')\n\n# Method 2: Set globally\ndata.set_universe(market='TSE_OTC', category='半導體', exclude_category='金融')\nprice = data.get('price:收盤價')\n```\n\nSee [data-reference.md](data-reference.md) for complete `data.universe()` usage.\n\n### ✅ Assign `resample` to Prevent Overtrading\n\n**DO:** Always specify `resample` parameter in `sim()`.\n\n```python\n# Monthly rebalancing\nsim(position, resample=\"M\")\n\n# Weekly rebalancing\nsim(position, resample=\"W\")\n\n# Use monthly revenue index\nrev = data.get('monthly_revenue:當月營收')\nsim(position, resample=rev.index)\n```\n\n**DON'T:** Omit `resample` (defaults to daily, causes excessive trading).\n\n---\n\n## Anti-Patterns (DON'T DO THIS)\n\n### ❌ Don't Use `==` for Float Comparisons\n\n**Reason:** Floating point precision issues.\n\n```python\n# ❌ BAD\ncondition = (close == 100.0)\n\n# ✅ GOOD - use inequalities or np.isclose()\nimport numpy as np\ncondition = np.isclose(close, 100.0)\n# Or better:\ncondition = (close > 99.9) & (close < 100.1)\n```\n\n### ❌ Don't Use `reindex()` on FinLabDataFrame\n\n**Reason:** FinLabDataFrame already automatically aligns indices/columns.\n\n```python\n# ❌ BAD - unnecessary reindexing\ndf1 = data.get(\"price:收盤價\")\ndf2 = data.get(\"monthly_revenue:當月營收\")\ndf2_reindexed = df2.reindex(df1.index, method='ffill')  # DON'T DO THIS\n\n# ✅ GOOD - automatic alignment\nposition = df1 > df1.average(60) & (df2 > df2.shift(1))\n```\n\n**Exception:** Only use `reindex()` for position DataFrame when changing to a specific resampling schedule:\n\n```python\n# ✅ Allowed - reindex position to monthly revenue dates\nrev = data.get('monthly_revenue:當月營收')\nposition_resampled = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n```\n\n### ❌ Don't Use For Loops\n\n**Reason:** FinLabDataFrame methods are vectorized and much faster.\n\n```python\n# ❌ BAD - iterating over rows\nfor date in close.index:\n    for stock in close.columns:\n        if close.loc[date, stock] > sma60.loc[date, stock]:\n            position.loc[date, stock] = True\n\n# ✅ GOOD - vectorized operations\nposition = close > sma60\n```\n\n### ❌ Don't Filter 注意股/處置股/全額交割股 Unless Asked\n\n**Reason:** These filters remove many stocks and should only be applied when explicitly requested.\n\n```python\n# ❌ DON'T do this by default\nis_regular = (\n    data.get(\"etl:noticed_stock_filter\") &\n    data.get(\"etl:disposal_stock_filter\") &\n    data.get(\"etl:full_cash_delivery_stock_filter\")\n)\nposition = position & is_regular\n\n# ✅ Only do this if user specifically asks to remove these stocks\n```\n\n### ❌ Don't Pass OHLCV to Technical Indicators\n\n**Reason:** `data.indicator()` automatically uses correct price data.\n\n```python\n# ❌ WRONG\nclose = data.get(\"price:收盤價\")\nrsi = data.indicator(\"RSI\", close, timeperiod=14)  # ERROR\n\n# ✅ CORRECT\nrsi = data.indicator(\"RSI\", timeperiod=14)  # Automatically uses close\n```\n\n---\n\n## Preventing Future Data Pollution\n\n**Critical:** Future data pollution (lookahead bias) occurs when you use information that wouldn't have been available at the time of decision-making. This silently corrupts backtests and makes them unrealistic.\n\n### ✅ Leave `df.index` As-Is\n\n**DO:** Keep index intact, even if it contains strings like \"2025Q1\".\n\n```python\n# ✅ GOOD - leave index as-is\nrevenue = data.get(\"monthly_revenue:當月營收\")\n# Index may contain strings like \"2022-01\", \"2022-02\", etc.\n# FinLabDataFrame aligns by shape in binary operations\nposition = revenue > revenue.shift(1)\n```\n\n**DON'T:** Manually assign to `df.index`.\n\n```python\n# ❌ FORBIDDEN - can corrupt shared data\ndf.index = new_index  # NEVER DO THIS\n```\n\n### ✅ Use Only Approved Resampling Method\n\n**DO:** Use exactly this pattern for resampling (datetime index required, use `.last()` only).\n\n```python\n# ✅ CORRECT resampling pattern\ndf = df.index_str_to_date().resample('M').last()\n```\n\n**DON'T:** Use other aggregation methods like `.mean()`, `.first()`, `.ffill()`.\n\n```python\n# ❌ WRONG\ndf = df.resample('M').mean()  # Can cause lookahead\ndf = df.resample('M').ffill()  # Can cause lookahead\n```\n\n### ✅ Use Only Approved Reindexing Method\n\n**DO:** Use exactly `method='ffill'` for reindexing.\n\n```python\n# ✅ CORRECT\ndf = df.reindex(target_index, method='ffill')\n```\n\n**DON'T:** Use other methods like `'bfill'` or `None`.\n\n```python\n# ❌ WRONG\ndf = df.reindex(target_index, method='bfill')  # Lookahead bias\ndf = df.reindex(target_index)  # Missing data\n```\n\n---\n\n## Stock Selection Patterns\n\n### Pattern 1: Limit to Top X% of Indicator\n\n```python\n# Select stocks in top 30% by momentum\nmomentum = close / close.shift(60) - 1\ntop_momentum = momentum.rank(axis=1, pct=True) > 0.7\n```\n\n### Pattern 2: Limit to Top N Stocks\n\n```python\n# Select top 10 stocks with lowest P/B ratio\npb = data.get(\"price_earning_ratio:股價淨值比\")\nposition = pb.is_smallest(10)\n\n# Select top 15 stocks meeting a condition\nvolume = data.get(\"price:成交股數\")\nliquid_stocks = volume.average(20) > 1000*1000\nposition = pb[liquid_stocks].is_smallest(15)\n```\n\n### Pattern 3: Entry/Exit with `hold_until()`\n\n```python\nclose = data.get(\"price:收盤價\")\npb = data.get(\"price_earning_ratio:股價淨值比\")\n\n# Define entry and exit signals\nentries = close > close.average(20)\nexits = close < close.average(60)\n\n# Hold until exit, limit to 10 stocks, rank by negative P/B\nposition = entries.hold_until(\n    exits,\n    nstocks_limit=10,\n    rank=-pb  # Negative for ascending order (low P/B preferred)\n)\n```\n\n### Pattern 4: Industry Ranking\n\n```python\n# Select top 20% within each industry\nroe = data.get(\"fundamental_features:ROE稅後\")\nindustry_top = roe.industry_rank() > 0.8\n```\n\n---\n\n## Backtesting Patterns\n\n### Pattern 1: Basic Backtest\n\n```python\nsim(position, resample=\"M\")\n```\n\n### Pattern 2: Backtest Within Date Range\n\n```python\nsim(position.loc['2020':'2023'], resample=\"M\")\n```\n\n### Pattern 3: Optuna Parameter Optimization\n\n```python\nimport optuna\nfrom finlab.backtest import sim\n\ndef run_strategy(params):\n    \"\"\"Strategy function that returns a report\"\"\"\n    sma_short = close.average(params['short'])\n    sma_long = close.average(params['long'])\n    position = (sma_short > sma_long)\n    report = sim(position, resample=\"M\", upload=False)\n    return report\n\ndef objective(trial):\n    params = {\n        'short': trial.suggest_int('short', 5, 30),\n        'long': trial.suggest_int('long', 40, 120)\n    }\n    report = run_strategy(params)\n    return report.metrics.sharpe_ratio()\n\n# Optimize with n_trials <= 10\nstudy = optuna.create_study(direction='maximize')\nstudy.optimize(objective, n_trials=10)\nprint(f\"Best params: {study.best_params}\")\n```\n\n### Pattern 4: Evaluate Strategy Condition Coverage\n\n```python\n# Check how often the condition is True (on average across stocks)\ncondition = close > close.average(60)\ncoverage = condition.sum(axis=1).loc['2020':].mean()\nprint(f\"Average stocks meeting condition: {coverage:.1f}\")\n```\n\n### Pattern 5: Adjust Rebalance Frequency\n\n```python\n# Weekly\nsim(position, resample=\"W\")\n\n# Monthly\nsim(position, resample=\"M\")\n\n# Quarterly\nsim(position, resample=\"Q\")\n\n# Custom: use monthly revenue index\nrev = data.get('monthly_revenue:當月營收')\nsim(position, resample=rev.index)\n```\n\n### Pattern 6: Adjust Rebalance Offset\n\n```python\n# Rebalance 1 week after period start\nsim(position, resample=\"M\", resample_offset=\"1W\")\n\n# Rebalance 1 month after quarter start\nsim(position, resample=\"Q\", resample_offset=\"1M\")\n```\n\n---\n\n## Error Handling\n\n### Error: `_ArrayMemoryError`\n\n**Solution:** Reset kernel and try again.\n\n```python\n# Call this if you encounter _ArrayMemoryError\nresetKernel()\n```\n\n### Error: `requests.exceptions.ConnectionError`\n\n**Solution:** Reset kernel and retry.\n\n```python\nresetKernel()\n```\n\n### Debugging Tips\n\n1. **Break down experiments into small steps**\n\n   ```python\n   # Step 1: Fetch data\n   close = data.get(\"price:收盤價\")\n   print(close.head())\n\n   # Step 2: Create condition\n   condition = close > close.average(60)\n   print(condition.head())\n\n   # Step 3: Select stocks\n   position = condition.is_largest(10)\n   print(position.head())\n   ```\n\n2. **Inspect variable values** after each step to ensure correctness.\n\n3. **Use print statements** to display intermediate DataFrames.\n\n---\n\n## Strategy Design Principles\n\n### Principle 1: Be Systematic\n\n- **Good:** Clearly define hypothesis, experiment setup, and evaluation criteria\n- **Good:** Import optuna to systematically explore parameter space\n- **Bad:** Randomly changing parameters without a clear plan\n\n### Principle 2: Start Simple\n\n- Begin with a baseline strategy\n- Add complexity incrementally\n- Test each addition separately\n\n### Principle 3: Write Clear, Maintainable Code\n\n- Use descriptive variable names\n- Add comments where logic isn't self-evident\n- Don't over-comment obvious operations\n\n---\n\n## Complete Pattern Examples\n\n### Example 1: Value + Momentum + Liquidity\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Fetch data\nclose = data.get(\"price:收盤價\")\npb = data.get(\"price_earning_ratio:股價淨值比\")\nvolume = data.get(\"price:成交股數\")\n\n# Create factors\nvalue = pb.rank(axis=1, pct=True) < 0.3  # Low P/B\nmomentum = close.rise(20)  # Rising\nliquidity = volume.average(20) > 500*1000  # Liquid\n\n# Combine\nposition = value & momentum & liquidity\nposition = pb[position].is_smallest(10)\n\n# Backtest\nreport = sim(position, resample=\"M\", stop_loss=0.08, upload=False)\nprint(f\"Annual Return: {report.metrics.annual_return():.2%}\")\nprint(f\"Sharpe Ratio: {report.metrics.sharpe_ratio():.2f}\")\nprint(f\"Max Drawdown: {report.metrics.max_drawdown():.2%}\")\n```\n\n### Example 2: Monthly Revenue Growth\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Fetch revenue data\nrev = data.get(\"monthly_revenue:當月營收\")\nrev_growth = data.get(\"monthly_revenue:去年同月增減(%)\")\n\n# Revenue momentum\nrev_ma3 = rev.average(3)\nrev_high = (rev_ma3 / rev_ma3.rolling(12).max()) == 1\n\n# Sustained growth\nstrong_growth = (rev_growth > 20).sustain(3)\n\n# Combine\nposition = rev_high & strong_growth\nposition = rev_growth[position].is_largest(10)\n\n# Reindex to monthly revenue dates\nposition_resampled = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n\n# Backtest\nreport = sim(position_resampled, upload=False)\n```\n\n---\n\n## See Also\n\n- [SKILL.md](SKILL.md) - Overview and quick start\n- [dataframe-reference.md](dataframe-reference.md) - FinLabDataFrame methods\n- [backtesting-reference.md](backtesting-reference.md) - Complete `sim()` API\n- [factor-examples.md](factor-examples.md) - 60+ complete examples\n",
  "data-reference": "# Data Reference\n\n## Overview\n\nThe FinLab data module provides comprehensive access to Taiwan stock market data, including prices, financial statements, fundamental metrics, institutional trading, and economic indicators. Use `data.get()` to retrieve any dataset using a simple path-based syntax.\n\n---\n\n## Usage\n\n### Basic Syntax\n\n```python\nfrom finlab import data\n\n# Retrieve data using TABLE:COLUMN format\ndf = data.get('price:收盤價')\n\n# For tables without columns, use TABLE directly\ninventory = data.get('inventory')\n```\n\n### Data Path Construction\n\nThe path is constructed using colons (`:`) to navigate hierarchical data structures:\n\n**Format:**\n- `<TABLE>:<COLUMN>` - For tables with multiple columns\n- `<TABLE>` - For tables without column structure\n\n**Example:**\n```python\n# Get closing price\nclosing_price = data.get('price:收盤價')\n\n# Get earnings per share\neps = data.get('fundamental_features:每股盈餘')\n\n# Get foreign investor trading volume\nforeign_investment = data.get('institutional_investors_trading_summary:外陸資買賣超股數(不含外資自營商)')\n```\n\n---\n\n## Universe Filtering\n\nLimit the data fetch scope by market or industry category using a context manager or global settings.\n\n### Supported Markets\n- `ALL` - All markets\n- `TSE` - Taiwan Stock Exchange (上市)\n- `OTC` - Over-The-Counter (上櫃)\n- `TSE_OTC` - Both TSE and OTC\n- `ETF` - Exchange Traded Funds\n\n### Supported Categories\n\n**Industry Categories:**\n光電業, 其他, 其他電子業, 化學工業, 半導體, 塑膠工業, 存託憑證, 建材營造, 文化創意業, 橡膠工業, 水泥工業, 汽車工業, 油電燃氣業, 玻璃陶瓷, 生技醫療, 生技醫療業, 紡織纖維, 航運業, 觀光事業, 貿易百貨, 資訊服務業, 農業科技, 通信網路業, 造紙工業, 金融, 鋼鐵工業, 電器電纜, 電子商務, 電子通路業, 電子零組件, 電機機械, 電腦及週邊, 食品工業\n\n**ETF Categories:**\ndomestic_etf, foreign_etf, leveraged_etf, vanilla_futures_etf, leveraged_futures_etf\n\n### Parameters\n\n- `market` (str): One of 'ALL', 'TSE', 'OTC', 'TSE_OTC', 'ETF'\n- `category` (str or list): Industry NAMES only (no numeric codes); supports regex fuzzy match (e.g. '電子' matches multiple electronics categories)\n- `exclude_category` (str or list or None): Excluded industry NAMES only (no numeric codes); same regex rules as category\n\n### Important Notes\n\n- Regex matching is used for categories. To match exact '其他', use '^其他$'\n- When both category and exclude_category are provided, select category first, then subtract exclude_category\n- Use data.universe ONLY to scope data.get() or backtest.sim() — do NOT wrap DataFrame/factor operations (e.g., position = ...)\n- Do NOT use category codes (代號) like '28'; use industry names instead (e.g., exclude_category='金融')\n\n### Examples\n\n**Context Manager (Recommended):**\n```python\nfrom finlab import data\n\n# Filter by market and category\nwith data.universe(market='TSE_OTC', category=['水泥工業']):\n    price = data.get('price:收盤價')\n\n# Exact match using regex\nwith data.universe(market='TSE_OTC', category=['^其他$']):\n    close_subset = data.get('price:收盤價')\n\n# Exclude specific categories\nwith data.universe(market='TSE_OTC', category=['水泥工業'], exclude_category=['金融']):\n    price = data.get('price:收盤價')\n```\n\n**Global Setting:**\n```python\nfrom finlab import data\n\ndata.set_universe(market='TSE_OTC', category='水泥工業', exclude_category='金融')\nprice = data.get('price:收盤價')\n```\n\n---\n\n## Data Catalog\n\n### Price & Trading Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `price` | 上市櫃市場成交資訊 | 成交股數, 成交筆數, 成交金額, 收盤價, 開盤價, 最低價, 最高價, 最後揭示買價, 最後揭示賣價, 最後揭示買量, 最後揭示賣量 |\n| `etl` | 還原權值股價 | adj_close, adj_open, adj_high, adj_low |\n| `intraday_odd_lot_trade` | 上市櫃盤中零股成交資訊 | 成交股數, 成交筆數, 成交金額, 收盤價, 開盤價, 最低價, 最高價, 最後揭示買價, 最後揭示賣價, 最後揭示買量, 最後揭示賣量 |\n| `after_market_odd_lot_trade` | 上市櫃盤後零股成交資訊 | 成交股數, 成交筆數, 成交金額, 成交價, 最後揭示買價, 最後揭示賣價, 最後揭示買量, 最後揭示賣量 |\n| `intraday_trading` | 現股當沖成交資訊 | 當日沖銷交易成交股數, 當日沖銷交易買進成交金額, 當日沖銷交易賣出成交金額, 得先賣後買當沖 |\n| `rotc_price` | 興櫃市場成交資訊 | 成交股數, 成交金額, 開盤價, 收盤價, 最高價, 最低價, 日均價, 成交筆數, 最後揭示買價, 最後揭示賣價 |\n\n### Valuation Metrics\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `price_earning_ratio` | 個股日本益比、殖利率及股價淨值比 | 殖利率(%), 本益比, 股價淨值比 |\n| `etl` | 個股市值 | market_value |\n\n### Revenue Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `monthly_revenue` | 上市櫃月營收 | 當月營收, 上月營收, 去年當月營收, 上月比較增減(%), 去年同月增減(%), 當月累計營收, 去年累計營收, 前期比較增減(%) |\n| `rotc_monthly_revenue` | 興櫃月營收 | 當月營收, 上月營收, 去年當月營收, 上月比較增減(%), 去年同月增減(%), 當月累計營收, 去年累計營收, 前期比較增減(%), 備註 |\n\n### Financial Statements\n\nThe `financial_statement` table contains comprehensive balance sheet, income statement, and cash flow data with 100+ columns including:\n\n**Balance Sheet Items:**\n- Assets: 現金及約當現金, 流動資產, 非流動資產, 資產總額\n- Liabilities: 流動負債, 非流動負債, 負債總額\n- Equity: 股本, 資本公積合計, 保留盈餘, 股東權益總額\n\n**Income Statement Items:**\n- Revenue & Costs: 營業收入淨額, 營業成本, 營業毛利\n- Expenses: 研究發展費, 推銷費用, 管理費用\n- Profit: 營業利益, 稅前淨利, 歸屬母公司淨利(損), 每股盈餘\n\n**Cash Flow Items:**\n- Operating: 營業活動之淨現金流入(流出)\n- Investing: 投資活動之淨現金流入(流出), 取得不動產_廠房及設備\n- Financing: 籌資活動之淨現金流入(流出), 發放現金股利\n\n### Fundamental Features\n\nThe `fundamental_features` table contains 50+ calculated financial metrics:\n\n**Profitability Metrics:**\n- ROA稅後息前, ROA綜合損益, ROE稅後, ROE綜合損益\n- 營業毛利率, 營業利益率, 稅前淨利率, 稅後淨利率\n\n**Growth Metrics:**\n- 營收成長率, 營業毛利成長率, 營業利益成長率, 稅前淨利成長率, 稅後淨利成長率\n\n**Efficiency Metrics:**\n- 總資產週轉次數, 應收帳款週轉率, 存貨週轉率, 固定資產週轉次數\n\n**Liquidity Metrics:**\n- 流動比率, 速動比率, 現金流量比率\n\n**Leverage Metrics:**\n- 負債比率, 總負債除總淨值\n\n**Per Share Metrics:**\n- 每股營業額, 每股營業利益, 每股現金流量, 每股稅前淨利, 每股綜合損益, 每股稅後淨利\n\n### Institutional Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `institutional_investors_trading_summary` | 三大法人買賣超 | 外陸資買進股數(不含外資自營商), 外陸資賣出股數(不含外資自營商), 外陸資買賣超股數(不含外資自營商), 外資自營商買進股數, 外資自營商賣出股數, 外資自營商買賣超股數, 投信買進股數, 投信賣出股數, 投信買賣超股數, 自營商買進股數(自行買賣), 自營商賣出股數(自行買賣), 自營商買賣超股數(自行買賣), 自營商買進股數(避險), 自營商賣出股數(避險), 自營商買賣超股數(避險) |\n| `foreign_investors_shareholding` | 外資持股比率 | 發行股數, 外資及陸資尚可投資股數, 全體外資及陸資持有股數, 外資及陸資尚可投資比率, 全體外資及陸資持股比率, 外資及陸資共用法令投資上限比率, 陸資法令投資上限比率 |\n\n### Margin Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `margin_transactions` | 融資券 | 融資買進, 融資賣出, 融資現金償還, 融資前日餘額, 融資今日餘額, 融資限額, 融券買進, 融券賣出, 融券現券償還, 融券前日餘額, 融券今日餘額, 融券限額, 資券互抵, 註記, 融資使用率, 融券使用率 |\n| `security_lending` | 借券 | 前日借券餘額, 借券, 借券還券, 借券增減, 借券餘額 |\n| `security_lending_sell` | 借券賣出 | 借券賣出, 借券賣出還券, 借券賣出餘額, 借券賣出限額 |\n\n### Insider Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `internal_equity_changes` | 內部人持股變化 | 發行股數, 董監增加股數, 董監減少股數, 董監持有股數, 董監持有股數占比, 經理人持有股數, 百分之十以上大股東持有股數, 市場別 |\n| `internal_equity_pledge` | 內部人質押 | 董監持股, 董監設質, 董監解質, 董監累計設質, 董監設質股數占比, 經理人持股, 百分之十以上大股東持有股數, 經理人及百分之十以上大股東設質股數, 經理人及百分之十以上大股東設質股數占比, 市場別 |\n| `inventory` | 集保餘額 | (Unstructured table - use directly) |\n\n### Corporate Actions\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `dividend_tse` | 上市除權息 | 除權息前收盤價, 除權息參考價, 權值+息值, 權息, 漲停價格, 跌停價格, 開盤競價基準, 減除股利參考價, 詳細資料, 最近一次申報資料 季別日期, 最近一次申報每股 (單位)淨值, 最近一次申報每股 (單位)盈餘, twse_divide_ratio |\n| `dividend_otc` | 上櫃除權息 | 除權息前收盤價, 除權息參考價, 權值, 息值, 權+息值, 權息, 漲停價格, 跌停價格, 開盤競價基準, 減除股利參考價, 現金股利, 每千股無償配股, 現金增資股數, 現金增資認購價, 公開承銷股數, 員工認購股數, 原股東認購數, 按持股比例千股認購, otc_divide_ratio |\n| `capital_reduction_tse` | 上市減資 | 恢復買賣日期, 減資原因, 恢復買賣參考價, 停止買賣前收盤價格, 漲停價格, 跌停價格, 開盤競價基準, 除權參考價, twse_cap_divide_ratio |\n| `capital_reduction_otc` | 上櫃減資 | 恢復買賣日期, 減資原因, 開始交易基準價, 最後交易之收盤價格, 減資恢復買賣開始日參考價格, 漲停價格, 跌停價格, 除權參考價, otc_cap_divide_ratio |\n| `treasury_stock` | 庫藏股 | 買回目的, 買回股份總金額上限, 預定買回股數, 買回價格區間-最低, 買回價格區間-最高, 預定買回期間-起, 預定買回期間-迄, 是否執行完畢, 本次已買回股數, 本次執行完畢已註銷或轉讓股數, 本次已買回股數佔預定買回股數比例(%), 本次已買回總金額, 本次平均每股買回價格, 本次買回股數佔公司已發行股份總數比例(%), 本次未執行完畢之原因 |\n\n### Market Indices\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `benchmark_return` | 回測基準 | 發行量加權股價報酬指數 |\n| `taiex_total_index` | 發行量加權股價指數歷史資料 | 開盤指數, 最高指數, 最低指數, 收盤指數 |\n| `stock_index_price` | 指數資訊 | 收盤指數, 漲跌百分比(%) |\n| `stock_index_vol` | 指數成交量資訊 | 成交股數, 成交金額, 成交筆數 |\n| `world_index` | 世界指數 | open, high, low, close, adj_close, volume |\n\n### Economic Indicators\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `tw_business_indicators` | 台灣景氣指標 | 景氣對策信號(分), 領先指標綜合指數(點), 領先指標不含趨勢指數(點), 同時指標綜合指數(點), 同時指標不含趨勢指數(點), 落後指標綜合指數(點), 落後指標不含趨勢指數(點) |\n| `tw_total_pmi` | 台灣製造業採購經理人指數 | 製造業PMI, 新增訂單數量, 生產數量, 人力僱用數量, 供應商交貨時間, 存貨, 客戶存貨, 原物料價格, 未完成訂單, 新增出口訂單, 進口原物料數量, 未來六個月展望 |\n| `tw_total_nmi` | 台灣非製造業採購經理人指數 | 臺灣非製造業NMI, 商業活動, 新增訂單, 人力僱用, 供應商交貨時間, 存貨, 採購價格, 未完成訂單, 服務輸出出口, 服務輸入進口, 服務收費價格, 存貨觀感, 未來六個月展望 |\n| `tw_monetary_aggregates` | 貨幣總計數年增率 | 年增率(%) |\n\n### Futures Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `futures_price` | 期貨日成交資訊 | 到期月份(週別), 開盤價, 最高價, 最低價, 收盤價, 漲跌價, 漲跌幅, 成交量, 未沖銷契約數 |\n| `futures_institutional_investors_trading_summary` | 期貨三大法人盤後資訊 | 多方交易口數, 空方交易口數, 多空交易口數淨額, 多方未平倉口數, 空方未平倉口數, 多空未平倉口數淨額, 多方交易契約金額(千元), 空方交易契約金額(千元), 多空交易契約金額淨額(千元), 多方未平倉契約金額(千元), 空方未平倉契約金額(千元), 多空未平倉契約金額淨額(千元) |\n\n### Convertible Bonds\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `cb_price` | 可轉換公司債成交資訊 | 成交張數, 成交筆數, 成交金額, 收盤價, 開盤價, 最低價, 最高價 |\n| `cb_converted_status` | 可轉換公司債每月轉換普通股 | 本月轉換張數, 轉(交)換或認股價格(元), 債券轉(交)換或認購普通股 |\n\n### Company Information\n\n| Table Name | Description |\n|-----------|-------------|\n| `company_basic_info` | 企業基本資訊 |\n| `company_main_business` | 企業主要經營業務 |\n| `important_subsidiary` | 企業重要子公司資訊 |\n| `security_categories` | 台股證券分類 |\n| `security_industry_themes` | 產業題材 |\n\n**Stock ID to Name Mapping:**\n```python\n# company_basic_info 的 index 是流水號，需用 stock_id 欄位對應\ninfo = data.get(\"company_basic_info\")\nname_map = dict(zip(info[\"stock_id\"], info[\"公司簡稱\"]))\n\n# 用法: name_map.get(\"2330\") -> \"台積電\"\ndf[\"股票名稱\"] = df.index.map(lambda x: name_map.get(x, x))\n```\n\n### Special Status\n\n| Table Name | Description | Usage |\n|-----------|-------------|-------|\n| `etl:disposal_stock_filter` | 排除處置股 | Boolean filter |\n| `etl:noticed_stock_filter` | 排除注意股 | Boolean filter |\n| `etl:full_cash_delivery_stock_filter` | 排除全額交割股 | Boolean filter |\n| `trading_attention` | 注意股 | Status table |\n| `disposal_information` | 處置股 | Status table |\n| `change_transaction` | 上市櫃變更交易 | 變更交易, 分盤交易 |\n\n### Special Dates\n\n| Table Name | Description |\n|-----------|-------------|\n| `etl:financial_statements_deadline` | 財報截止日 |\n| `etl:financial_statements_disclosure_dates` | 財報電子檔上傳日 |\n| `financial_statements_upload_detail` | 財報電子檔上傳紀錄 |\n\n---\n\n## Plotting Data\n\nChinese characters are fully supported, so you can plot data directly using matplotlib or seaborn. Always include labels, legends, and titles.\n\n**Example:**\n```python\nimport matplotlib.pyplot as plt\nfrom finlab import data\n\n# Get closing prices for multiple stocks\nclose = data.get('price:收盤價')\n\n# Plot specific stocks\nclose[['2330', '2317', '2454']].plot(figsize=(12, 6))\nplt.title('台積電、鴻海、聯發科股價走勢')\nplt.xlabel('日期')\nplt.ylabel('收盤價 (元)')\nplt.legend(['台積電', '鴻海', '聯發科'])\nplt.grid(True)\nplt.show()\n```\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods for data manipulation\n- [Backtesting Reference](backtesting-reference.md) - How to use data in backtesting\n- [Factor Examples](factor-examples.md) - Practical examples using various datasets\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor effectiveness\n",
  "dataframe-reference": "# FinlabDataFrame Reference\n\n## Overview\n\nFinlabDataFrame is a powerful extension of pandas DataFrame specifically designed for financial data analysis and backtesting. It provides enhanced functionality for trading strategy development, including automatic index/column alignment, moving averages, entry/exit signal detection, and industry-based ranking.\n\n## Key Features\n\n- Automatic re-alignment of indices and columns during arithmetic and logical operations\n- Built-in methods for moving averages and technical calculations\n- Entry/exit signal detection for trading strategies\n- Industry-based grouping and ranking\n- Integration with backtesting workflows\n\n---\n\n## Constructor\n\n### FinlabDataFrame\n\nConverts a regular pandas DataFrame to a FinlabDataFrame with enhanced financial data processing capabilities.\n\n**Signature:**\n```python\nFinlabDataFrame(df: pd.DataFrame)\n```\n\n**Parameters:**\n- `df` (pd.DataFrame, required): A pandas DataFrame to be converted to FinlabDataFrame\n\n**Returns:**\n- An instance of FinlabDataFrame with enhanced financial data processing capabilities\n\n**Example:**\n```python\nfrom finlab.dataframe import FinlabDataFrame\nimport pandas as pd\n\n# Convert existing pandas DataFrame to FinlabDataFrame\nregular_df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ndf = FinlabDataFrame(regular_df)\n\n# FinlabDataFrame is also automatically returned by data.get()\nfrom finlab import data\nprice_df = data.get('price:收盤價')  # Returns a FinlabDataFrame\n```\n\n---\n\n## Methods\n\n### average\n\nCalculates a moving average over n periods.\n\n**Signature:**\n```python\naverage(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of periods for the moving average\n\n**Returns:**\n- FinlabDataFrame representing the moving average\n\n**Example:**\n```python\nsma = close.average(10)\n```\n\n---\n\n### is_largest\n\nReturns a boolean DataFrame where True values represent the top n largest values for each date. Eliminates the need for row-by-row iteration with nlargest, making stock selection simple and efficient.\n\n**Signature:**\n```python\nis_largest(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of top values to select on each date\n\n**Returns:**\n- Boolean FinlabDataFrame with True for top n stocks on each date\n\n**Example:**\n```python\n# Select 10 stocks with highest market value daily\ntop_market_value = data.get('etl:market_value').is_largest(10)\n```\n\n---\n\n### is_smallest\n\nReturns a boolean DataFrame where True values represent the n smallest values for each date. Perfect for stock selection without looping through each date with nsmallest.\n\n**Signature:**\n```python\nis_smallest(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of smallest values to select on each date\n\n**Returns:**\n- Boolean FinlabDataFrame with True for bottom n stocks on each date\n\n**Example:**\n```python\n# Select 10 stocks with lowest PE ratio daily\nlowest_pe = data.get('price_earning_ratio:本益比').is_smallest(10)\n```\n\n---\n\n### sustain\n\nChecks whether the condition is sustained over a moving window of n days, returning True if the sum meets or exceeds a given threshold.\n\n**Signature:**\n```python\nsustain(nwindow: int, nsatisfy: int = None) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `nwindow` (int, required): Window length (in days)\n- `nsatisfy` (int, optional): Minimum number of True values required; defaults to nwindow if not provided\n\n**Returns:**\n- Boolean FinlabDataFrame\n\n**Example:**\n```python\nsustained = df.rise().sustain(2)\n```\n\n---\n\n### rise\n\nDetermines if values are rising compared to n periods before.\n\n**Signature:**\n```python\nrise(n: int = 1) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, optional, default=1): Number of periods to compare\n\n**Returns:**\n- Boolean FinlabDataFrame indicating rising trends\n\n**Example:**\n```python\nrising = df.rise(10)\n```\n\n---\n\n### fall\n\nDetermines if values are falling compared to n periods before.\n\n**Signature:**\n```python\nfall(n: int = 1) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, optional, default=1): Number of periods to compare\n\n**Returns:**\n- Boolean FinlabDataFrame indicating falling trends\n\n**Example:**\n```python\nfalling = df.fall(10)\n```\n\n---\n\n### groupby_category\n\nGroups the DataFrame columns based on their associated industry or category.\n\n**Signature:**\n```python\ngroupby_category() -> pd.core.groupby.generic.DataFrameGroupBy\n```\n\n**Returns:**\n- A GroupBy object with groups defined by industry categories\n\n**Example:**\n```python\ngrouped = df.groupby_category()\nmean_category = grouped.mean()\n```\n\n---\n\n### entry_price\n\nRetrieves the adjusted price corresponding to entry signals based on a specified price type.\n\n**Signature:**\n```python\nentry_price(trade_at: str = 'close') -> FinlabDataFrame\n```\n\n**Parameters:**\n- `trade_at` (str, optional, default='close'): The price type to reference ('close' or 'open')\n\n**Returns:**\n- FinlabDataFrame of entry prices\n\n**Example:**\n```python\nprice = df.entry_price()\n```\n\n---\n\n### industry_rank\n\nCalculates ranking scores for stocks within their respective industries, where 0 indicates the lowest and 1 the highest.\n\n**Signature:**\n```python\nindustry_rank(categories: list = None) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `categories` (list, optional): Optional list of industry categories to consider. If omitted, all industries are used\n\n**Returns:**\n- FinlabDataFrame of industry ranking scores\n\n**Example:**\n```python\nrank_scores = df.industry_rank()\n```\n\n---\n\n### is_entry\n\nIdentifies entry signal points where the condition switches to True.\n\n**Signature:**\n```python\nis_entry() -> FinlabDataFrame\n```\n\n**Returns:**\n- Boolean FinlabDataFrame indicating entry signals\n\n**Example:**\n```python\nentry_signals = df.is_entry()\n```\n\n---\n\n### is_exit\n\nIdentifies exit signal points where the condition switches from True to False.\n\n**Signature:**\n```python\nis_exit() -> FinlabDataFrame\n```\n\n**Returns:**\n- Boolean FinlabDataFrame indicating exit signals\n\n**Example:**\n```python\nexit_signals = df.is_exit()\n```\n\n---\n\n### quantile_row\n\nComputes the specified quantile for each row in the DataFrame.\n\n**Signature:**\n```python\nquantile_row(c: float) -> pd.Series\n```\n\n**Parameters:**\n- `c` (float, required): Quantile value (e.g., 0.9 for 90th percentile)\n\n**Returns:**\n- pandas Series containing the quantile value per row\n\n**Example:**\n```python\nq90 = df.quantile_row(0.9)\n```\n\n---\n\n### hold_until\n\nGenerates trading positions based on entry signals until exit signals occur. Supports additional criteria such as a maximum number of stocks, stop-loss/take-profit thresholds, and ranking to prioritize entries.\n\n**Signature:**\n```python\nhold_until(\n    exit: FinlabDataFrame,\n    nstocks_limit: int = None,\n    stop_loss: float = -np.inf,\n    take_profit: float = np.inf,\n    trade_at: str = 'close',\n    rank: FinlabDataFrame = None,\n    market: str = 'AUTO'\n) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `exit` (FinlabDataFrame, required): A FinlabDataFrame representing exit signals\n- `nstocks_limit` (int, optional): Maximum number of stocks to hold (if None, holds all available)\n- `stop_loss` (float, optional, default=-np.inf): Stop loss threshold (default: -np.inf, meaning off)\n- `take_profit` (float, optional, default=np.inf): Take profit threshold (default: np.inf, meaning off)\n- `trade_at` (str, optional, default='close'): Price reference for evaluating stop loss/take profit ('close' or 'open')\n- `rank` (FinlabDataFrame, optional): Optional FinlabDataFrame for ranking stocks when entries exceed the limit\n- `market` (str, optional, default='AUTO'): Market identifier; default is 'AUTO'\n\n**Returns:**\n- Boolean FinlabDataFrame with positions (True indicates holding a stock)\n\n**Example:**\n```python\nfrom finlab import data\nclose = data.get('price:收盤價')\npb = data.get('price_earning_ratio:股價淨值比')\n\nentries = close > close.average(20)\nexits = close < close.average(60)\n\nposition = entries.hold_until(exits, nstocks_limit=10, rank=-pb)\n```\n\n---\n\n## Related References\n\n- [Backtesting Reference](backtesting-reference.md) - Learn how to backtest strategies using FinlabDataFrame\n- [Data Reference](data-reference.md) - Explore available data sources\n- [Factor Examples](factor-examples.md) - See practical examples of using FinlabDataFrame in strategies\n",
  "factor-analysis-reference": "# Factor Analysis Reference\n\n## Overview\n\nThe FinLab factor analysis module provides comprehensive tools for evaluating factor effectiveness, calculating Information Coefficient (IC), analyzing factor trends, and computing factor contributions using Shapley values. These tools help you understand which factors drive returns and how to construct better trading strategies.\n\n**Import:**\n```python\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return,\n    calc_ic,\n    ic,\n    calc_metric,\n    calc_shapley_values,\n    calc_centrality,\n    calc_regression_stats\n)\n```\n\n---\n\n## Quick Start\n\n### Basic Factor Analysis Workflow\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import generate_features_and_labels, calc_factor_return, calc_ic\n\n# Get data\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:當月營收')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\nprint(factor_return.head())\n\n# Calculate IC (Information Coefficient)\nic_df = calc_ic(features, labels, rank=True)\nprint(ic_df.mean())\n```\n\n---\n\n## Functions\n\n### generate_features_and_labels\n\nGenerate factor features and labels: combines factors into a feature DataFrame and generates excess return labels.\n\n**Signature:**\n```python\ngenerate_features_and_labels(\n    dfs: Dict[str, Union[pd.DataFrame, Callable]],\n    resample: str\n) -> tuple[pd.DataFrame, pd.Series]\n```\n\n**Parameters:**\n- `dfs` (dict, required): Factor dictionary where keys are factor names and values are DataFrame or callable functions that return DataFrame (standard input for feature.combine)\n- `resample` (str, required): Resampling frequency string (e.g., 'M', 'Q', 'Y'), used for feature and label generation\n\n**Returns:**\n- `tuple[pd.DataFrame, pd.Series]`: (features, labels). features has date index with columns as factor names; labels are excess returns with the same index\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:當月營收')\n\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\nprint(f'Features shape: {features.shape}')\nprint(f'Labels shape: {labels.shape}')\n```\n\n---\n\n### calc_factor_return\n\nCalculate equal-weight portfolio returns based on features and labels. Automatically validates features as boolean values, calculates equal-weight portfolio returns per factor, and outputs starting from the first non-empty row.\n\n**Signature:**\n```python\ncalc_factor_return(\n    features: pd.DataFrame,\n    labels: pd.Series\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with date index, factor names as columns, and boolean values\n- `labels` (pd.Series, required): Label Series with date index and excess returns as values\n\n**Returns:**\n- `pd.DataFrame`: Equal-weight portfolio period returns indexed by date with factor names as columns, starting from the first non-empty row\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_factor_return, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:當月營收')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\nprint(factor_return.head())\n\n# Analyze cumulative returns\ncumulative_return = (1 + factor_return).cumprod()\ncumulative_return.plot(figsize=(12, 6))\n```\n\n---\n\n### calc_ic\n\nCalculate the correlation coefficient (IC) between features and labels. Optionally rank features first for Rank IC. Outputs starting from the first non-empty row.\n\n**Signature:**\n```python\ncalc_ic(\n    features: pd.DataFrame,\n    labels: pd.Series,\n    rank: bool = False\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with MultiIndex (date, stock_id) and factor names as columns\n- `labels` (pd.Series, required): Label Series with MultiIndex (date, stock_id)\n- `rank` (bool, optional, default=False): Whether to rank features first for calculating Rank IC\n\n**Returns:**\n- `pd.DataFrame`: IC values for each date and factor, starting from the first non-empty row\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_ic, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:當月營收')\n\n# Generate features and labels (MultiIndex: date, stock_id)\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate Rank IC\nic_df = calc_ic(features, labels, rank=True)\nprint(ic_df.head())\n\n# Analyze IC statistics\nprint(ic_df.mean())  # Mean IC\nprint(ic_df.std())   # IC volatility\nprint(ic_df.mean() / ic_df.std())  # IC IR (Information Ratio)\n```\n\n---\n\n### ic\n\nCalculate Information Coefficient (IC) for factors. Internally calls calc_metric with cross-sectional correlation as the evaluation function.\n\n**Signature:**\n```python\nic(\n    factor: pd.DataFrame | Dict[str, pd.DataFrame],\n    adj_close: pd.DataFrame,\n    days: list[int] = [10, 20, 60, 120]\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `factor` (pd.DataFrame or dict, required): Factor data as DataFrame (columns are stock IDs) or dict[str, DataFrame] (keys are factor names)\n- `adj_close` (pd.DataFrame, required): Adjusted closing price DataFrame (columns are stock IDs) for calculating future returns\n- `days` (list[int], optional, default=[10, 20, 60, 120]): Prediction horizon list for calculating d-day future returns\n\n**Returns:**\n- `pd.DataFrame`: IC for each factor at different prediction horizons. Column names are <factor>_<days>, indexed by date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import ic\n\n# Build factor and price\nfactor = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate IC (correlation coefficient)\nic_df = ic(factor, adj_close)\nprint(ic_df.head())\n\n# Analyze IC at different horizons\nprint(ic_df.mean())\nic_df.plot(figsize=(12, 6))\n```\n\n---\n\n### calc_metric\n\nCalculate evaluation metrics for factors and future returns at multiple prediction horizons. Supports single DataFrame or mapping of factor names to DataFrames. Automatically aligns and trims time series.\n\n**Signature:**\n```python\ncalc_metric(\n    factor: pd.DataFrame | Dict[str, pd.DataFrame],\n    adj_close: pd.DataFrame,\n    days: list[int] = [10, 20, 60, 120],\n    func = corr\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `factor` (pd.DataFrame or dict, required): Factor data as DataFrame (columns are stock IDs) or dict[str, DataFrame] (keys are factor names)\n- `adj_close` (pd.DataFrame, required): Adjusted closing price DataFrame (columns are stock IDs) for calculating future returns\n- `days` (list[int], optional, default=[10, 20, 60, 120]): Prediction horizon list for calculating d-day future returns\n- `func` (callable, optional): Aggregation function for each date group. Takes DataFrame with 'ret' and 'f' columns and returns a single statistic. Default is corr (correlation coefficient)\n\n**Returns:**\n- `pd.DataFrame`: Evaluation results for each factor at different prediction horizons. Column names are <factor>_<days>, indexed by date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_metric\n\n# Build factor and price\nfactor = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate evaluation metric (default: correlation coefficient)\nmetric_df = calc_metric(factor, adj_close)\nprint(metric_df.head())\n\n# Use custom metric function\ndef custom_metric(df):\n    # Calculate Spearman correlation\n    return df['f'].corr(df['ret'], method='spearman')\n\nmetric_df = calc_metric(factor, adj_close, func=custom_metric)\n```\n\n---\n\n### calc_shapley_values\n\nCalculate Shapley values for each factor to measure marginal contribution to portfolio performance using cooperative game theory. Enumerates all factor subsets and averages marginal contributions. Computational complexity is O(2^n) where n is the number of factors.\n\n**Signature:**\n```python\ncalc_shapley_values(\n    features: pd.DataFrame,\n    labels: pd.Series\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with date index, factor names as columns, and boolean values (True indicates selected)\n- `labels` (pd.Series, required): Label Series with MultiIndex ('datetime', 'stock_id') and excess returns as values\n\n**Returns:**\n- `pd.DataFrame`: Daily Shapley values for each factor. Indexed by date with factor names as columns\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_shapley_values, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:當月營收')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate Shapley values\nshapley_df = calc_shapley_values(features, labels)\nprint(shapley_df.head())\n\n# Analyze average contribution\nprint(shapley_df.mean())\nshapley_df.plot(figsize=(12, 6))\n```\n\n**Note:** Due to computational complexity, this function is best used with a small number of factors (typically < 10).\n\n---\n\n### calc_centrality\n\nCalculate rolling asset centrality for time series data. This is a generic function applicable to any DataFrame with time index and asset columns (e.g., factor returns). It is frequency-agnostic with rolling window specified by integer window_periods.\n\n**Signature:**\n```python\ncalc_centrality(\n    return_df: pd.DataFrame,\n    window_periods: int,\n    n_components: int = 1\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `return_df` (pd.DataFrame, required): Time series DataFrame indexed by date with assets (e.g., factor names) as columns. Despite the name return_df, it can be any asset time series\n- `window_periods` (int, required): Rolling window length in number of data points. For monthly data, 3 means 3 months\n- `n_components` (int, optional, default=1): Number of principal components for PCA calculation\n\n**Returns:**\n- `pd.DataFrame`: DataFrame with rolling centrality scores. Indexed by date (window end date) with assets as columns\n\n**Example:**\n```python\nimport pandas as pd\nfrom finlab.tools.factor_analysis import calc_centrality\n\n# Assume we have factor return time series data\ndata = {\n    'FactorA': [0.1, 0.2, 0.15, 0.12, 0.11],\n    'FactorB': [0.05, 0.04, 0.06, 0.07, 0.08],\n}\nindex = pd.to_datetime(['2025-01-01','2025-01-02','2025-01-03','2025-01-04','2025-01-05'])\nreturn_df = pd.DataFrame(data, index=index)\n\ncentrality_df = calc_centrality(return_df, window_periods=3, n_components=1)\nprint(centrality_df.head())\n```\n\n---\n\n### calc_regression_stats\n\nPerform linear regression on each time series in a DataFrame and return statistics (slope, p-value, R², tail estimate, and trend classification). Uses vectorized implementation without SciPy dependency.\n\n**Signature:**\n```python\ncalc_regression_stats(\n    df: pd.DataFrame,\n    p_value_threshold: float = 0.05,\n    r_squared_threshold: float = 0.1\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `df` (pd.DataFrame, required): Time series DataFrame indexed by DatetimeIndex with different metrics as columns\n- `p_value_threshold` (float, optional, default=0.05): P-value threshold for trend significance\n- `r_squared_threshold` (float, optional, default=0.1): R² threshold for trend explanatory power\n\n**Returns:**\n- `pd.DataFrame`: Regression statistics for each column including slope, p_value, r_squared, tail_estimate, and trend\n\n**Example:**\n```python\n# Assume ic_df is a time series of factor IC\nfrom finlab.tools.factor_analysis import calc_regression_stats\n\ntrend_stats = calc_regression_stats(ic_df)\nprint(trend_stats.head())\n\n# Filter for statistically significant upward trends\nsignificant_up = trend_stats[(trend_stats['p_value'] < 0.05) & (trend_stats['slope'] > 0)]\nprint(significant_up)\n```\n\n---\n\n## Advanced Analysis Examples\n\n### Complete Factor Analysis Pipeline\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return,\n    calc_ic,\n    calc_regression_stats,\n    calc_shapley_values\n)\nimport matplotlib.pyplot as plt\n\n# 1. Define factors\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:當月營收')\npb = data.get('price_earning_ratio:股價淨值比')\n\n# 2. Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'small_cap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue_growth': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n    'low_pb': pb.rank(pct=True, axis=1) < 0.3,\n}, resample='M')\n\n# 3. Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\ncumulative_return = (1 + factor_return).cumprod()\n\n# 4. Calculate IC\nic_df = calc_ic(features, labels, rank=True)\nprint(\"Average IC:\")\nprint(ic_df.mean())\n\n# 5. Analyze IC trends\nic_trends = calc_regression_stats(ic_df)\nprint(\"\\nIC Trend Statistics:\")\nprint(ic_trends)\n\n# 6. Calculate Shapley values (factor contributions)\nshapley_df = calc_shapley_values(features, labels)\nprint(\"\\nAverage Shapley Values:\")\nprint(shapley_df.mean())\n\n# 7. Visualization\nfig, axes = plt.subplots(3, 1, figsize=(14, 12))\n\n# Plot cumulative returns\ncumulative_return.plot(ax=axes[0])\naxes[0].set_title('Cumulative Factor Returns')\naxes[0].set_ylabel('Cumulative Return')\naxes[0].grid(True)\n\n# Plot IC over time\nic_df.plot(ax=axes[1])\naxes[1].set_title('Information Coefficient (IC) Over Time')\naxes[1].set_ylabel('IC')\naxes[1].axhline(y=0, color='r', linestyle='--', alpha=0.3)\naxes[1].grid(True)\n\n# Plot Shapley values\nshapley_df.plot(ax=axes[2])\naxes[2].set_title('Shapley Values (Factor Contributions)')\naxes[2].set_ylabel('Shapley Value')\naxes[2].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n---\n\n### Multi-Horizon IC Analysis\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import ic\nimport matplotlib.pyplot as plt\n\n# Calculate factor\nrsi = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate IC at multiple horizons\nic_df = ic(rsi, adj_close, days=[5, 10, 20, 40, 60, 120])\n\n# Analyze IC statistics\nprint(\"IC Mean:\")\nprint(ic_df.mean())\nprint(\"\\nIC Std:\")\nprint(ic_df.std())\nprint(\"\\nIC IR (Mean/Std):\")\nprint(ic_df.mean() / ic_df.std())\n\n# Visualization\nfig, axes = plt.subplots(2, 1, figsize=(14, 10))\n\n# IC time series\nic_df.plot(ax=axes[0])\naxes[0].set_title('IC Across Different Horizons')\naxes[0].set_ylabel('IC')\naxes[0].axhline(y=0, color='r', linestyle='--', alpha=0.3)\naxes[0].grid(True)\n\n# IC distribution\nic_df.plot(kind='box', ax=axes[1])\naxes[1].set_title('IC Distribution Across Horizons')\naxes[1].set_ylabel('IC')\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n---\n\n### Factor Combination Analysis\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return\n)\nimport pandas as pd\n\n# Define multiple factors\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:當月營收')\n\n# Generate individual features\nindividual_features, labels = generate_features_and_labels({\n    'small_cap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue_growth': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample='M')\n\n# Create combined features\ncombined_features = pd.DataFrame(index=individual_features.index)\ncombined_features['small_cap'] = individual_features['small_cap']\ncombined_features['revenue_growth'] = individual_features['revenue_growth']\ncombined_features['momentum'] = individual_features['momentum']\ncombined_features['small_cap+revenue'] = individual_features['small_cap'] & individual_features['revenue_growth']\ncombined_features['all_three'] = individual_features['small_cap'] & individual_features['revenue_growth'] & individual_features['momentum']\n\n# Calculate returns for all combinations\nfactor_return = calc_factor_return(combined_features, labels)\ncumulative_return = (1 + factor_return).cumprod()\n\n# Compare performance\nprint(\"Cumulative Return (Final):\")\nprint(cumulative_return.iloc[-1])\n\nprint(\"\\nAnnualized Return:\")\nprint(factor_return.mean() * 12)\n\nprint(\"\\nAnnualized Volatility:\")\nprint(factor_return.std() * (12 ** 0.5))\n\nprint(\"\\nSharpe Ratio:\")\nprint((factor_return.mean() / factor_return.std()) * (12 ** 0.5))\n\n# Visualization\ncumulative_return.plot(figsize=(14, 6))\nplt.title('Factor Combination Performance Comparison')\nplt.ylabel('Cumulative Return')\nplt.grid(True)\nplt.show()\n```\n\n---\n\n## Best Practices\n\n1. **Use Rank IC for robustness** - Rank IC is more stable than raw IC\n2. **Analyze IC over time** - Look for consistent positive IC, not just average IC\n3. **Check IC trend** - Use calc_regression_stats to identify deteriorating factors\n4. **Calculate Shapley values** - Understand true factor contributions in multi-factor strategies\n5. **Test multiple horizons** - Different factors may work at different time scales\n6. **Combine complementary factors** - Factors with low correlation often work better together\n7. **Monitor factor centrality** - High centrality may indicate overcrowding\n8. **Validate out-of-sample** - Always test on unseen data periods\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Available data sources\n- [Factor Examples](factor-examples.md) - Practical factor calculations\n- [Machine Learning Reference](machine-learning-reference.md) - ML-based factor analysis\n- [Backtesting Reference](backtesting-reference.md) - Test factor-based strategies\n",
  "factor-examples": "# Factor Examples and Strategy Reference\n\n## Overview\n\nThis comprehensive guide provides practical examples of factor calculations, stock selection conditions, and complete trading strategies using the FinLab framework. All examples are organized by category for easy reference.\n\n---\n\n## Table of Contents\n\n1. [Common Data Paths](#common-data-paths)\n2. [Technical Indicators](#technical-indicators)\n3. [Calculation Examples](#calculation-examples)\n4. [Stock Selection Conditions](#stock-selection-conditions)\n   - [Technical Analysis](#technical-analysis)\n   - [Fundamental Analysis](#fundamental-analysis)\n   - [Chip Analysis](#chip-analysis)\n   - [Market Indicators](#market-indicators)\n   - [Filter Tools](#filter-tools)\n5. [Complete Strategy Examples](#complete-strategy-examples)\n\n---\n\n## Common Data Paths\n\n```python\nfrom finlab import data\n\n# Price data\n收盤價 = data.get(\"price:收盤價\")\n成交股數 = data.get(\"price:成交股數\")\n\n# Revenue data\n當月營收 = data.get(\"monthly_revenue:當月營收\")\n去年同月增減 = data.get(\"monthly_revenue:去年同月增減(%)\")\n\n# Valuation metrics\n本益比 = data.get(\"price_earning_ratio:本益比\")\n殖利率 = data.get(\"price_earning_ratio:殖利率(%)\")\n股價淨值比 = data.get(\"price_earning_ratio:股價淨值比\")\n\n# Fundamental features\nROE稅後 = data.get(\"fundamental_features:ROE稅後\")\n營業毛利率 = data.get(\"fundamental_features:營業毛利率\")\n自由現金流量 = data.get(\"fundamental_features:自由現金流量\")\n\n# Market value and institutional trading\n市值 = data.get(\"etl:market_value\")\n外陸資買賣超股數 = data.get(\"institutional_investors_trading_summary:外陸資買賣超股數(不含外資自營商)\")\n投信買賣超股數 = data.get(\"institutional_investors_trading_summary:投信買賣超股數\")\n```\n\n---\n\n## Technical Indicators\n\n### Momentum Indicators\n\n```python\nfrom finlab import data\n\n# ADX - Average Directional Index\nadx = data.indicator(\"ADX\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# RSI - Relative Strength Index\nrsi = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# MACD - Moving Average Convergence Divergence\nmacd, macdsignal, macdhist = data.indicator(\"MACD\", adjust_price=False, resample=\"D\",\n                                              fastperiod=12, slowperiod=26, signalperiod=9)\n\n# MOM - Momentum\nmom = data.indicator(\"MOM\", adjust_price=False, resample=\"D\", timeperiod=10)\n\n# ROC - Rate of Change\nroc = data.indicator(\"ROC\", adjust_price=False, resample=\"D\", timeperiod=10)\n\n# Stochastic Oscillator\nslowk, slowd = data.indicator(\"STOCH\", adjust_price=False, resample=\"D\",\n                               fastk_period=5, slowk_period=3, slowk_matype=0,\n                               slowd_period=3, slowd_matype=0)\n\n# Williams %R\nwillr = data.indicator(\"WILLR\", adjust_price=False, resample=\"D\", timeperiod=14)\n```\n\n### Moving Averages and Bands\n\n```python\n# Simple Moving Average\nsma = data.indicator(\"SMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# Exponential Moving Average\nema = data.indicator(\"EMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# Bollinger Bands\nupperband, middleband, lowerband = data.indicator(\"BBANDS\", timeperiod=20,\n                                                    nbdevup=2.0, nbdevdn=2.0, matype=0)\n\n# Weighted Moving Average\nwma = data.indicator(\"WMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# TEMA - Triple Exponential Moving Average\ntema = data.indicator(\"TEMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n```\n\n### Volatility Indicators\n\n```python\n# ATR - Average True Range\natr = data.indicator(\"ATR\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# NATR - Normalized ATR\nnatr = data.indicator(\"NATR\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# TRANGE - True Range\ntrange = data.indicator(\"TRANGE\", adjust_price=False, resample=\"D\")\n```\n\n### Volume Indicators\n\n```python\n# AD - Chaikin A/D Line\nad = data.indicator(\"AD\", adjust_price=False, resample=\"D\")\n\n# OBV - On Balance Volume\nobv = data.indicator(\"OBV\", adjust_price=False, resample=\"D\")\n\n# ADOSC - Chaikin A/D Oscillator\nadosc = data.indicator(\"ADOSC\", adjust_price=False, resample=\"D\",\n                        fastperiod=3, slowperiod=10)\n```\n\n---\n\n## Calculation Examples\n\n### Price-Based Calculations\n\n```python\nfrom finlab import data\n\n收盤價 = data.get(\"price:收盤價\")\n\n# 60-day moving average\nsma = 收盤價.average(60)\n\n# 60-day maximum price\nprice_max = 收盤價.rolling(60).max()\n\n# 60-day minimum price\nprice_min = 收盤價.rolling(60).min()\n\n# 20-day price change percentage\nprice_pct = 收盤價.pct_change(periods=20)\n\n# Price rising compared to 60 days ago\nprice_rise = 收盤價.rise(60)\n\n# Price falling compared to 60 days ago\nprice_fall = 收盤價.fall(60)\n\n# Price rising for 3 consecutive days\nrise_sustain = 收盤價.rise().sustain(3)\n\n# Price rising at least 2 out of last 3 days\nrise_nsatisfy = 收盤價.rise().sustain(nwindow=3, nsatisfy=2)\n\n# Price falling for 3 consecutive days\nfall_sustain = 收盤價.fall().sustain(3)\n\n# Top 10 highest prices in market\nprice_largest = 收盤價.is_largest(10)\n\n# Top 10 lowest prices in market\nprice_smallest = 收盤價.is_smallest(10)\n```\n\n### Volume-Based Calculations\n\n```python\n成交股數 = data.get(\"price:成交股數\")\n\n# 20-day average volume\nvol_ma = 成交股數.average(20)\n\n# 20-day cumulative volume\nvol_cumsum = 成交股數.rolling(20).sum()\n```\n\n### Revenue-Based Calculations\n\n```python\n當月營收 = data.get(\"monthly_revenue:當月營收\")\n去年同月增減 = data.get(\"monthly_revenue:去年同月增減(%)\")\n\n# 3-month average revenue\nrev_ma = 當月營收.average(3)\n\n# Revenue YoY growth > 20% for 3 consecutive months\nrev_rise_sustain = (去年同月增減 > 20).sustain(3)\n\n# Revenue YoY growth ranking (percentile)\nrev_rise_nsatisfy = 去年同月增減.rank(pct=True, axis=1)\n```\n\n### Special Calculations\n\n```python\n# Align position to monthly revenue dates\nrev = data.get(\"monthly_revenue:當月營收\")\nposition = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n\n# Replace infinity with NaN\ninf_ratio = (data.get(\"financial_statement:研究發展費\") /\n             data.get(\"financial_statement:營業收入淨額\")).replace(np.inf, np.nan)\n\n# Inventory - large holders (>400 lots)\ninventory = data.get(\"inventory\")\nboss_inventory = inventory[\n    (inventory.持股分級.astype(int) >= 12) &\n    (inventory.持股分級.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"占集保庫存數比例\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"占集保庫存數比例\"]\n\n# Inventory - retail investors (<50 lots)\nsmall_inv = inventory[\n    (inventory.持股分級.astype(int) <= 8)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"占集保庫存數比例\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"占集保庫存數比例\"]\n```\n\n---\n\n## Stock Selection Conditions\n\n### Technical Analysis\n\n#### Moving Average Strategies\n\n```python\n收盤價 = data.get(\"price:收盤價\")\n\n# Price above 60-day MA\nsma60 = 收盤價 > 收盤價.average(60)\n\n# Price breaks above 60-day MA\nsma60_breakout = (收盤價 > 收盤價.average(60)) & (收盤價.shift() < 收盤價.average(60).shift())\n\n# Price breaks below 60-day MA\nsma60_breakdown = (收盤價 < 收盤價.average(60)) & (收盤價.shift() > 收盤價.average(60).shift())\n\n# Bullish alignment (5/10/20 MA)\nlong_ma_pattern = (收盤價 > 收盤價.average(5)) & (收盤價 > 收盤價.average(10)) & (收盤價 > 收盤價.average(20))\n\n# Bearish alignment (5/10/20 MA)\nshort_ma_pattern = (收盤價 < 收盤價.average(5)) & (收盤價 < 收盤價.average(10)) & (收盤價 < 收盤價.average(20))\n```\n\n#### Price Extreme Conditions\n\n```python\n# New 5-day high\nnew_high = (收盤價 / 收盤價.rolling(5).max()) == 1\n\n# New 5-day low\nnew_low = (收盤價 / 收盤價.rolling(5).min()) == 1\n\n# Making new 3-day highs for 5 consecutive days\nprice_boost = ((收盤價 / 收盤價.rolling(3).max()) == 1).sustain(5)\n\n# Making new 3-day lows for 5 consecutive days\nprice_crash = ((收盤價 / 收盤價.rolling(3).min()) == 1).sustain(5)\n\n# Not making new 3-day highs for 5 consecutive days\nprice_pressure = ((收盤價 / 收盤價.rolling(3).max()) < 1).sustain(5)\n\n# Not making new 3-day lows for 5 consecutive days\nprice_support = ((收盤價 / 收盤價.rolling(3).min()) > 1).sustain(5)\n\n# 20-day price change less than 20%\nprice_pct_cond = 收盤價.pct_change(periods=20) < 0.20\n```\n\n#### Volume Conditions\n\n```python\n成交股數 = data.get(\"price:成交股數\")\n\n# 20-day average volume > 1,000,000\nvol_ma = 成交股數.average(20) > 1000000\n\n# Volume above 60-day MA\nvol_ma = 成交股數 > 成交股數.average(60)\n\n# Volume making new 3-day highs for 5 consecutive days\nvol_boost = ((成交股數 / 成交股數.rolling(3).max()) == 1).sustain(5)\n\n# Volume making new 3-day lows for 5 consecutive days\nvol_crash = ((成交股數 / 成交股數.rolling(3).min()) == 1).sustain(5)\n```\n\n#### Technical Indicator Conditions\n\n```python\n# RSI golden cross\nrsi1 = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=14)\nrsi2 = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=28)\nrsi_gold_cross = (rsi1 > rsi2) & (rsi1.shift() < rsi2.shift())\n\n# RSI overbought for 5 consecutive days\nrsi = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=5)\nrsi_high_trend = (rsi > 80).sustain(5)\n\n# KD golden cross\nslowk, slowd = data.indicator(\"STOCH\", adjust_price=False, resample=\"D\",\n                               fastk_period=5, slowk_period=3, slowk_matype=0,\n                               slowd_period=3, slowd_matype=0)\nkd_gold_cross = (slowk > slowd) & (slowk.shift() < slowd.shift())\n\n# 10-day volatility (ATR)\nadj_close = data.get(\"etl:adj_close\")\nvolatility = data.indicator(\"ATR\", adjust_price=True, resample=\"D\", timeperiod=10) / adj_close\n\n# Breaking above Keltner Channel upper band\nema = data.indicator(\"EMA\", adjust_price=True, resample=\"D\", timeperiod=10)\natr = data.indicator(\"ATR\", adjust_price=True, resample=\"D\", timeperiod=10)\nkeltner_up = ema + 2 * atr\ncond = (adj_close > keltner_up) & (adj_close.shift() < keltner_up.shift())\n\n# Breaking above Bollinger upper band\nupperband, middleband, lowerband = data.indicator(\"BBANDS\", timeperiod=10)\ncond = (收盤價 > upperband) & (收盤價.shift() < upperband.shift())\n\n# Breaking below Bollinger lower band\ncond = (收盤價 < lowerband) & (收盤價.shift() > lowerband.shift())\n\n# MACD golden cross\nmacd, macd_signal, macd_hist = data.indicator(\"MACD\", fastperiod=12, slowperiod=26, signalperiod=9)\nmacd_golden = (macd > macd_signal) & (macd.shift() < macd_signal.shift())\n\n# MACD histogram turns positive\nmacd_hist_positive = (macd_hist > 0) & (macd_hist.shift() < 0)\n\n# RSI oversold breakout (breaks above 30)\nrsi = data.indicator(\"RSI\", timeperiod=14)\nrsi_oversold_breakout = (rsi > 30) & (rsi.shift() < 30)\n\n# RSI overbought breakdown (drops below 70)\nrsi_overbought_breakdown = (rsi < 70) & (rsi.shift() > 70)\n\n# KD low-level golden cross (K < 50)\nslowk, slowd = data.indicator(\"STOCH\", fastk_period=9, slowk_period=3, slowk_matype=0, slowd_period=3, slowd_matype=0)\nkd_low_golden = (slowk > slowd) & (slowk.shift() < slowd.shift()) & (slowk < 50)\n```\n\n---\n\n### Fundamental Analysis\n\n#### Revenue Growth\n\n```python\n去年同月增減 = data.get(\"monthly_revenue:去年同月增減(%)\")\n上月比較增減 = data.get(\"monthly_revenue:上月比較增減(%)\")\n當月營收 = data.get(\"monthly_revenue:當月營收\")\n\n# Revenue YoY growth > 30%\nrev_yy = 去年同月增減 > 30\n\n# Revenue MoM growth > 30%\nrev_mm = 上月比較增減 > 30\n\n# 3-month average revenue > 12-month average revenue\nrev_sl_compare = (當月營收.average(3) > 當月營收.average(12))\n\n# 3-month average revenue YoY growth > 12-month average revenue YoY growth\nrev_sl_growth = 當月營收.average(3).pct_change(12) > 當月營收.average(12).pct_change(12)\n\n# 2-month average revenue at 12-month high\nrev_new_high = (當月營收.average(2) / 當月營收.average(2).rolling(12, min_periods=6).max()) == 1\n\n# At least 2 out of last 3 months with YoY growth > 20%\nrev_rise_nsatisfy = (去年同月增減 > 20).sustain(nwindow=3, nsatisfy=2)\n\n# Revenue YoY growth ranking > 80th percentile\nrev_rise_nsatisfy = 去年同月增減.rank(pct=True, axis=1) > 0.80\n```\n\n#### Valuation Metrics\n\n```python\n本益比 = data.get(\"price_earning_ratio:本益比\")\n股價淨值比 = data.get(\"price_earning_ratio:股價淨值比\")\n殖利率 = data.get(\"price_earning_ratio:殖利率(%)\")\n\n# PE ratio between 5 and 20\npe_range = (5 <= 本益比) & (本益比 <= 20)\n\n# PB ratio between 0.5 and 2\npb_range = (0.5 <= 股價淨值比) & (股價淨值比 <= 2)\n\n# Dividend yield between 3% and 10%\nyield_range = (3 <= 殖利率) & (殖利率 <= 10)\n```\n\n#### Profitability Metrics\n\n```python\n營運現金流 = data.get(\"fundamental_features:營運現金流\")\n營業毛利率 = data.get(\"fundamental_features:營業毛利率\")\n營業利益率 = data.get(\"fundamental_features:營業利益率\")\n稅前淨利率 = data.get(\"fundamental_features:稅前淨利率\")\n稅後淨利率 = data.get(\"fundamental_features:稅後淨利率\")\n業外收支營收率 = data.get(\"fundamental_features:業外收支營收率\")\n每股盈餘 = data.get(\"financial_statement:每股盈餘\")\nROA綜合損益 = data.get(\"fundamental_features:ROA綜合損益\")\nROE綜合損益 = data.get(\"fundamental_features:ROE綜合損益\")\n\n# Operating cash flow > 0 for 1 quarter\nope_cashflow_trend = (營運現金流 > 0).sustain(1)\n\n# Gross margin > 3% for 1 quarter\ngpm_trend = (營業毛利率 > 3).sustain(1)\n\n# Operating margin > 3% for 1 quarter\nopm_trend = (營業利益率 > 3).sustain(1)\n\n# Pre-tax margin > 3% for 1 quarter\nbtpm_trend = (稅前淨利率 > 3).sustain(1)\n\n# After-tax margin > 3% for 1 quarter\natpm_trend = (稅後淨利率 > 3).sustain(1)\n\n# Non-operating income ratio > 3% for 1 quarter\nopm_trend = (業外收支營收率 > 3).sustain(1)\n\n# EPS > 0 for 4 consecutive quarters\neps_trend = (每股盈餘 > 0).sustain(4)\n\n# ROA > 0% for 4 consecutive quarters\nroa_trend = (ROA綜合損益 > 0).sustain(4)\n\n# ROE > 0% for 4 consecutive quarters\nroe_trend = (ROE綜合損益 > 0).sustain(4)\n```\n\n#### Leverage Metrics\n\n```python\n負債比率 = data.get(\"fundamental_features:負債比率\")\n\n# Debt ratio < 50% for 4 consecutive quarters\ndebt_trend = (負債比率 < 50).sustain(4)\n```\n\n---\n\n### Chip Analysis\n\n#### Institutional Trading\n\n```python\nfrom finlab import data\n\n# Foreign institutional net buy ratio > 10% in 1 day\niit = data.get(\"institutional_investors_trading_summary:外陸資買賣超股數(不含外資自營商)\")\nvol = data.get(\"price:成交股數\")\niit_ratio = iit.rolling(1).sum() / vol.rolling(1).sum() > 0.1\n\n# Investment trust net buy ratio > 10% in 1 day\n投信買賣超股數 = data.get(\"institutional_investors_trading_summary:投信買賣超股數\")\n成交股數 = data.get(\"price:成交股數\")\nict_ratio = 投信買賣超股數.rolling(1).sum() / 成交股數.rolling(1).sum() > 0.1\n\n# Foreign net buy > 200,000 shares for 2 consecutive days\nitt = data.get(\"institutional_investors_trading_summary:外陸資買賣超股數(不含外資自營商)\")\nitt_trend = (itt > 200000).sustain(2)\n\n# Investment trust net buy > 200,000 shares for 2 consecutive days\nict_trend = (投信買賣超股數 > 200000).sustain(2)\n\n# Three major institutional investors all buying (三大法人同買)\n外資 = data.get(\"institutional_investors_trading_summary:外陸資買賣超股數(不含外資自營商)\")\n投信 = data.get(\"institutional_investors_trading_summary:投信買賣超股數\")\n自營商 = data.get(\"institutional_investors_trading_summary:自營商買賣超股數(自行買賣)\")\n三大法人同買 = (外資 > 0) & (投信 > 0) & (自營商 > 0)\n連續同買 = 三大法人同買.sustain(3)\nposition = 外資[連續同買].is_largest(10)\n```\n\n#### Shareholding Distribution\n\n```python\ninventory = data.get(\"inventory\")\n董監持有股數占比 = data.get(\"internal_equity_changes:董監持有股數占比\")\n\n# Large holders (>400 lots) shareholding >= 30%\nboss_inv = inventory[\n    (inventory.持股分級.astype(int) >= 12) &\n    (inventory.持股分級.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"占集保庫存數比例\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"占集保庫存數比例\"] >= 30\n\n# Large holders (>800 lots) shareholding >= 30%\nboss_inv = inventory[\n    (inventory.持股分級.astype(int) >= 14) &\n    (inventory.持股分級.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"占集保庫存數比例\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"占集保庫存數比例\"] >= 30\n\n# Large holders (>400 lots) increasing for 3 consecutive periods\nfrom finlab import dataframe\nboss_inv_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.持股分級.astype(int) >= 12) &\n        (inventory.持股分級.astype(int) <= 15)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"占集保庫存數比例\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"占集保庫存數比例\"]\n).rise().sustain(3)\n\n# Retail investors (<50 lots) shareholding <= 30%\nsmall_inv = inventory[\n    (inventory.持股分級.astype(int) <= 8)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"占集保庫存數比例\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"占集保庫存數比例\"] <= 30\n\n# Retail investors (<50 lots) decreasing for 3 consecutive periods\nfrom finlab import dataframe\nsmall_inv_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.持股分級.astype(int) <= 8)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"占集保庫存數比例\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"占集保庫存數比例\"]\n).fall().sustain(3)\n\n# Total number of shareholders decreasing for 3 consecutive periods\ninv_small_people_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.人數.astype(int) == 17)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"人數\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"人數\"]\n).fall().sustain(3)\n\n# Director/supervisor shareholding > 30%\nboss_hold = 董監持有股數占比 > 30\n\n# Director/supervisor shareholding increasing compared to 1 month ago\nboss_hold_rise = 董監持有股數占比.rise(1)\n```\n\n#### Day Trading and Margin\n\n```python\n當日沖銷交易成交股數 = data.get(\"intraday_trading:當日沖銷交易成交股數\")\n成交股數 = data.get(\"price:成交股數\")\n融資使用率 = data.get(\"margin_transactions:融資使用率\")\n融券使用率 = data.get(\"margin_transactions:融券使用率\")\n融券今日餘額 = data.get(\"margin_transactions:融券今日餘額\")\n融資今日餘額 = data.get(\"margin_transactions:融資今日餘額\")\n\n# Day trading ratio < 10%\nday_trade_ratio = 當日沖銷交易成交股數 / 成交股數 / 2 < 0.1\n\n# Margin utilization > 0% for 1 day\nmargin_used_raio = (融資使用率 > 0).sustain(1)\n\n# Short selling utilization > 0% for 1 day\nmargin_sell_used_raio = (融券使用率 > 0).sustain(1)\n\n# Short/Margin ratio > 0% for 1 day\nmargin_trend = (融券今日餘額 / 融資今日餘額 > 0).sustain(1)\n```\n\n---\n\n### Market Indicators\n\n```python\n# ADLs (Advance-Decline Line with Smoothing)\ndef ADLs_position(short_par=20, long_par=55):\n    close = data.get(\"price:收盤價\")\n    close_diff = close.diff()\n    total_stocks = (~close.isna()).sum(1)\n    rise_stocks = (close_diff > 0).sum(1)\n    ADLs = rise_stocks / total_stocks - 0.5\n    short_ADLs_ma = ADLs.rolling(short_par).mean()\n    long_ADLs_ma = ADLs.rolling(long_par).mean()\n    cond = ~close.isna()\n    cond1 = short_ADLs_ma >= long_ADLs_ma\n    position = cond & cond1\n    return position\n\n# VIX (Volatility Index)\ndef vix_position(short_par=5, long_par=20):\n    df = data.get(\"world_index:open\")\n    vix = df[\"^VIX\"].dropna()\n    short_vix_ma = vix.rolling(short_par).mean()\n    long_vix_ma = vix.rolling(long_par).mean()\n    close = data.get(\"price:收盤價\")\n    cond = ~close.isna()\n    cond1 = short_vix_ma <= long_vix_ma\n    cond1 = cond1.reindex(close.index)\n    position = cond & cond1\n    return position\n\n# Market Long/Short Alignment Count\ndef ls_order_position(short=5, mid=10, long=30):\n    close = data.get(\"price:收盤價\")\n    short_ma = close.average(short)\n    mid_ma = close.average(mid)\n    long_ma = close.average(long)\n    long_order = (short_ma >= mid_ma) & (mid_ma >= long_ma)\n    long_order = long_order.sum(1)\n    short_order = (short_ma < mid_ma) & (mid_ma < long_ma)\n    short_order = short_order.sum(1)\n    entry = long_order > short_order\n    cond = ~close.isna()\n    position = cond & entry\n    return position\n\n# Margin Maintenance Ratio\ndef margin_position(short_par=5, long_par=30):\n    融資券總餘額 = data.get(\"margin_balance:融資券總餘額\").fillna(method=\"ffill\")\n    融資今日餘額 = data.get(\"margin_transactions:融資今日餘額\")\n    close = data.get(\"price:收盤價\")\n    融資總餘額 = 融資券總餘額[[\"上市融資交易金額\", \"上櫃融資交易金額\"]].sum(axis=1)\n    融資餘額市值 = (融資今日餘額 * close * 1000).sum(axis=1)[融資今日餘額.index]\n    mt_rate = (融資餘額市值 / 融資總餘額)\n    mt_rate = mt_rate.dropna()\n    short_ma = mt_rate.rolling(short_par).mean()\n    long_ma = mt_rate.rolling(long_par).mean()\n    entry = short_ma >= long_ma\n    cond = ~close.isna()\n    position = cond & entry\n    return position\n```\n\n---\n\n### Filter Tools\n\n```python\nfrom finlab import data\n\n# Filter out attention stocks\nnoticed_stock_filter = data.get(\"etl:noticed_stock_filter\")\n\n# Filter out disposal stocks\ndisposal_stock_filter = data.get(\"etl:disposal_stock_filter\")\n\n# Filter out full cash delivery stocks\nfull_cash_delivery_stock_filter = data.get(\"etl:full_cash_delivery_stock_filter\")\n\n# Filter out KY stocks\nsc = data.get(\"security_categories\")\nposition_col = position.columns\nky_filter = position_col[~position_col.isin(list(sc[sc[\"name\"].str.contains(\"KY\")][\"stock_id\"]))]\nposition = position[ky_filter]\n\n# Limit backtest to specific industry\ndata.set_universe(market=\"TSE_OTC\", category=\"建材營造\")\n```\n\n---\n\n## Complete Strategy Examples\n\n### 1. New High Strategy\n\nSelect stocks making 250-day new highs.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get(\"price:收盤價\")\nposition = (close == close.rolling(250).max())\nsim(position, resample=\"M\", name=\"創年新高策略\")\n```\n\n---\n\n### 2. Revenue Momentum Strategy\n\nSelect stocks with strong recent revenue performance.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\nimport pandas as pd\n\nrev = data.get(\"monthly_revenue:當月營收\")\nrev_rf = data.get(\"monthly_revenue:去年同月增減(%)\")\nvol = data.get(\"price:成交股數\") / 1000\n\nrev_recent_3 = rev.rolling(3).sum()\nvol_avg = vol.average(10)\n\ncond1 = (rev_recent_3 / rev_recent_3.rolling(24, min_periods=12).max()) == 1\ncond2 = vol_avg > 300\ncond_all = cond1 & cond2\n\nresult = rev_rf * (cond_all)\nposition = result[result > 0].is_largest(10).reindex(rev.index_str_to_date().index, method=\"ffill\")\n\nsim(position=position, stop_loss=0.3, position_limit=0.1)\n```\n\n---\n\n### 3. Cash Flow Strategy\n\nSelect stocks with positive cash flows across all categories.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n營業現金流 = data.get(\"financial_statement:營業活動之淨現金流入_流出\")\n投資現金流 = data.get(\"financial_statement:投資活動之淨現金流入_流出\")\n融資現金流 = data.get(\"financial_statement:籌資活動之淨現金流入_流出\")\n\nposition = (營業現金流 > 0) & (投資現金流 > 0) & (融資現金流 > 0)\nreport = sim(position, resample=\"M\", name=\"現金流正數\")\n```\n\n---\n\n### 4. PEG Strategy\n\nPrice-Earnings to Growth ratio strategy.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\npe = data.get(\"price_earning_ratio:本益比\")\nrev = data.get(\"monthly_revenue:當月營收\")\nrev_ma3 = rev.average(3)\nrev_ma12 = rev.average(12)\n營業利益成長率 = data.get(\"fundamental_features:營業利益成長率\")\n\npeg = (pe / 營業利益成長率)\ncond1 = rev_ma3 / rev_ma12 > 1.1\ncond2 = rev / rev.shift(1) > 0.9\ncond_all = cond1 & cond2\n\nresult = peg * (cond_all)\nposition = result[result > 0].is_smallest(10).reindex(rev.index_str_to_date().index, method=\"ffill\")\n\nsim(position=position, name=\"peg_rev\", fee_ratio=1.425/1000/3, stop_loss=0.1)\n```\n\n---\n\n### 5. Momentum + ROE Filter Strategy\n\nCombine price momentum with ROE filter.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Download ROE and closing price\nroe = data.get(\"fundamental_features:ROE稅後\")\nclose = data.get(\"price:收盤價\")\n\nposition = ((close / close.shift(60)).is_largest(30) & (roe > 0))\n\n# Backtest, rebalance monthly (M)\nreport = sim(position, resample=\"M\")\n```\n\n---\n\n### 6. Low PB Strategy\n\nPrice-to-Book ratio strategy with technical filter.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\npb = data.get(\"price_earning_ratio:股價淨值比\")\nclose = data.get(\"price:收盤價\")\n\nbuy = (1 / (pb * close) * (close > close.average(60)) * (close > 5)).is_largest(20)\nsim(buy, resample=\"Q\")\n```\n\n---\n\n### 7. Triple RSI Strategy\n\nAdvanced RSI-based strategy with multiple timeframes.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\nimport pandas as pd\nfrom finlab import dataframe\n\nclose = data.get(\"price:收盤價\")\nroe = data.get(\"fundamental_features:ROE稅後\")\n\nrsi1 = data.indicator(\"RSI\", timeperiod=20)\nrsi2 = data.indicator(\"RSI\", freq=\"D\", timeperiod=60)\nrsi3 = data.indicator(\"RSI\", freq=\"D\", timeperiod=120)\n\nbuy = (rsi3 > 55) & (rsi1 / rsi1.shift(3) > 1.02) & (roe > 0) & \\\n      dataframe.FinlabDataFrame(rsi1 > 75).sustain(3) & (rsi2 < 75)\nsell = buy.shift(60) | (close < close.average(60))\n\nposition = pd.DataFrame(np.nan, index=buy.index, columns=buy.columns)\nposition[buy] = 1\nposition[sell] = 0\nposition = position.ffill().fillna(0)\n\nreport = sim(position.loc[\"2014\":], resample=\"W\")\n```\n\n---\n\n### 8. High RSI Strategy\n\nSimple high RSI momentum strategy.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nrsi = data.indicator(\"RSI\")\nposition = rsi.is_largest(20)\nreport = sim(position, resample=\"W\", name=\"高RSI策略\")\n```\n\n---\n\n### 9. Entry/Exit Signal Example\n\nUsing hold_until for explicit entry and exit signals.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get(\"price:收盤價\")\npb = data.get(\"price_earning_ratio:股價淨值比\")\n\nsma20 = close.average(20)\nsma60 = close.average(60)\n\nentries = close > sma20\nexits = close < sma60\n\nposition = entries.hold_until(exits, nstocks_limit=10, rank=-pb)\nsim(position)\n```\n\n---\n\n### 10. Long/Short Strategy\n\nExample of simultaneous long and short positions.\n\n```python\nfrom finlab import data\nfrom finlab import backtest\n\nclose = data.get(\"price:收盤價\")\nposition = close < 0  # Start with all False\n\nposition[\"2330\"] = 0.5   # Long TSMC with 50% weight\nposition[\"1101\"] = -0.5  # Short Taiwan Cement with 50% weight\n\nreport = backtest.sim(position)\n```\n\n---\n\n## Best Practices\n\n1. **Use vectorized operations** - Never use for loops on FinlabDataFrame\n2. **Set appropriate resample periods** - Use 'M', 'Q', or revenue.index to avoid overtrading\n3. **Combine multiple factors** - Single factor strategies are often less robust\n4. **Apply filters** - Remove special status stocks (disposal, attention, full cash delivery)\n5. **Control position size** - Use position_limit and nstocks_limit\n6. **Set stop loss/take profit** - Protect against large losses\n7. **Universe filtering** - Use data.universe() to scope data.get() calls only\n8. **Proper alignment** - Let FinlabDataFrame handle index/column alignment automatically\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Backtesting Reference](backtesting-reference.md) - Backtest your strategies\n- [Data Reference](data-reference.md) - Complete data catalog\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n- [Machine Learning Reference](machine-learning-reference.md) - ML-based strategies\n",
  "machine-learning-reference": "# Machine Learning Reference\n\n## Overview\n\nThe FinLab machine learning module provides tools for creating ML-based trading strategies. It includes feature engineering, label generation, and integration with popular ML libraries like scikit-learn, XGBoost, and LightGBM.\n\n**Import:**\n```python\nfrom finlab.ml import feature, label\n```\n\n---\n\n## Table of Contents\n\n1. [Feature Engineering](#feature-engineering)\n2. [Label Generation](#label-generation)\n3. [Complete ML Workflow](#complete-ml-workflow)\n4. [Best Practices](#best-practices)\n\n---\n\n## Feature Engineering\n\n### feature.ta_names\n\nGenerate a list of technical indicator feature names with randomized parameters.\n\n**Signature:**\n```python\nfeature.ta_names(\n    lb: int = 1,\n    ub: int = 10,\n    n: int = 1,\n    factory: Optional[Factory] = None\n) -> List[str]\n```\n\n**Parameters:**\n- `lb` (int, optional, default=1): Lower bound of the multiplier for default technical indicator parameters\n- `ub` (int, optional, default=10): Upper bound of the multiplier for default technical indicator parameters\n- `n` (int, optional, default=1): Number of random samples for each technical indicator\n- `factory` (optional, default=None): Factory object to generate technical indicators. Defaults to TalibIndicatorFactory\n\n**Returns:**\n- `List[str]`: A list of technical indicator feature names\n\n**Example:**\n```python\nimport finlab.ml.feature as f\n\n# Generate 5 random variations for each TA-Lib indicator\nfeature_names = f.ta_names(n=5)\nprint(feature_names[:10])\n```\n\n---\n\n### feature.ta\n\nCalculate technical indicator values for a list of feature names.\n\n**Signature:**\n```python\nfeature.ta(\n    feature_names: Optional[List[str]],\n    factories = None,\n    resample = None,\n    start_time = None,\n    end_time = None,\n    adj = False,\n    cpu = -1,\n    **kwargs\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `feature_names` (list, optional, default=None): List of technical indicator feature names. Defaults to None (generates default names)\n- `factories` (dict, optional, default=None): Dictionary of factories to generate technical indicators. Defaults to {'talib': TalibIndicatorFactory()}\n- `resample` (str, optional, default=None): Frequency to resample data (e.g., 'W', 'M'). Defaults to None\n- `start_time` (str, optional, default=None): Start time of the data\n- `end_time` (str, optional, default=None): End time of the data\n- `adj` (bool, optional, default=False): Whether to use adjusted prices\n- `cpu` (int, optional, default=-1): Number of CPU cores for parallel processing. -1 uses all available cores\n- `**kwargs`: Additional keyword arguments to pass to the resampler function\n\n**Returns:**\n- `pd.DataFrame`: Technical indicator feature names and values, indexed by ('datetime', 'instrument')\n\n**Example:**\n```python\nimport finlab.ml.feature as f\n\n# Method 1: Generate default indicators with random parameters\nfeatures1 = f.ta()\nprint(features1.head())\n\n# Method 2: Generate specific indicator with defined parameters, resampled weekly\nfeature_names = ['talib.MACD__macdhist__fastperiod__52__slowperiod__212__signalperiod__75__']\nfeatures2 = f.ta(feature_names, resample='W')\nprint(features2.head())\n```\n\n**Important Notes:**\n- `feature.ta` can only calculate values for feature names generated by `feature.ta_names` randomly\n- Do NOT use `feature.ta` and `feature.ta_names` by default. Use `data.indicator` instead for static feature names\n- If you want static feature names, use `data.indicator('SMA', timeperiod=20)` which supports all TA-Lib indicators\n\n---\n\n### feature.combine\n\nCombine multiple feature DataFrames into a single DataFrame.\n\n**Signature:**\n```python\nfeature.combine(\n    features: Dict[str, pd.DataFrame],\n    resample = None,\n    sample_filter = None,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `features` (dict, required): Dictionary where keys are feature names and values are DataFrames (index=datetime, columns=instrument)\n- `resample` (str, optional, default=None): Optional argument to resample data in features (e.g., 'W', 'M')\n- `sample_filter` (pd.DataFrame, optional, default=None): Boolean DataFrame (index=date, columns=instrument) representing the filter of features\n- `**kwargs`: Additional keyword arguments to pass to the resampler function\n\n**Returns:**\n- `pd.DataFrame`: All input features combined, indexed by ('datetime', 'instrument')\n\n**Example:**\n```python\nfrom finlab import data\nimport finlab.ml.feature as f\n\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:股價淨值比'),\n    'rsi': data.indicator('RSI')\n}\n\ncombined_features = f.combine(features_dict, resample='M')\nprint(combined_features.head())\n```\n\n**Important Notes:**\n- `feature.combine` can handle misaligned indices and missing data automatically\n- Set `resample` to 'W', '2W', `data.get(\"monthly_revenue:當月營收\").index`, `data.get(\"fundamental_feature:ROE稅後\").deadline().index`, 'ME', 'QE', etc. to avoid excessive data points and high RAM consumption\n- Use `sample_filter` parameter to filter unwanted data points (e.g., `sample_filter = data.get('price:成交股數') > 200_000`)\n\n---\n\n## Label Generation\n\n### label.return_percentage\n\nCalculate the percentage change of market prices over a given period.\n\n**Signature:**\n```python\nlabel.return_percentage(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    bfill = False,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency for output data (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods to calculate percentage change over\n- `trade_at_price` (str, optional, default='close'): Price for execution ('open', 'high', 'low', 'close')\n- `bfill` (bool, optional, default=False): Whether to backfill missing price data before calculation\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Percentage change of stock prices, aligned to input index\n\n**Example:**\n```python\nfrom finlab.ml import label\n\n# Assume features is your feature DataFrame\ny = label.return_percentage(features.index, resample='M', period=1)\n```\n\n---\n\n### label.excess_over_mean\n\nCalculate the excess return over the cross-sectional mean return for a given period.\n\n**Signature:**\n```python\nlabel.excess_over_mean(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods for return calculation\n- `trade_at_price` (str, optional, default='close'): Price for return calculation ('open', 'high', 'low', 'close')\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Excess return over the mean, aligned to input index\n\n**Example:**\n```python\nfrom finlab.ml import label\n\n# Excess return over market mean\ny = label.excess_over_mean(features.index, resample='M', period=1)\n```\n\n---\n\n### label.excess_over_median\n\nCalculate the excess return over the cross-sectional median return for a given period.\n\n**Signature:**\n```python\nlabel.excess_over_median(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods for return calculation\n- `trade_at_price` (str, optional, default='close'): Price for return calculation\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Excess return over the median, aligned to input index\n\n---\n\n### label.daytrading_percentage\n\nCalculate the intraday percentage change (close / open - 1).\n\n**Signature:**\n```python\nlabel.daytrading_percentage(\n    index: pd.Index,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument, typically from a feature DataFrame\n- `**kwargs`: Additional arguments passed to internal resampler function\n\n**Returns:**\n- `pd.Series`: Intraday percentage change, aligned to input index\n\n---\n\n### label.maximum_adverse_excursion\n\nCalculate the maximum adverse excursion (lowest price relative to entry) over a given period.\n\n**Signature:**\n```python\nlabel.maximum_adverse_excursion(\n    index: pd.Index,\n    period = 1,\n    trade_at_price = 'close'\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `period` (int, optional, default=1): Number of periods to look forward for minimum price\n- `trade_at_price` (str, optional, default='close'): Entry price to compare against ('open', 'high', 'low', 'close')\n\n**Returns:**\n- `pd.Series`: Maximum adverse excursion, aligned to input index\n\n---\n\n### label.maximum_favorable_excursion\n\nCalculate the maximum favorable excursion (highest price relative to entry) over a given period.\n\n**Signature:**\n```python\nlabel.maximum_favorable_excursion(\n    index: pd.Index,\n    period = 1,\n    trade_at_price = 'close'\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `period` (int, optional, default=1): Number of periods to look forward for maximum price\n- `trade_at_price` (str, optional, default='close'): Entry price to compare against\n\n**Returns:**\n- `pd.Series`: Maximum favorable excursion, aligned to input index\n\n---\n\n## Complete ML Workflow\n\n### Basic LightGBM Regression Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom finlab.backtest import sim\nfrom finlab.dataframe import FinlabDataFrame\nfrom lightgbm import LGBMRegressor\nimport pandas as pd\n\n# Step 1: Feature Engineering\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:股價淨值比'),\n    'pe': data.get('price_earning_ratio:本益比'),\n    'rsi': data.indicator('RSI', timeperiod=14),\n    'revenue_growth': data.get('monthly_revenue:去年同月增減(%)'),\n    'roe': data.get('fundamental_features:ROE稅後'),\n}\n\n# Combine features with filtering\nsample_filter = data.get('price:成交股數') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\n\n# Step 2: Label Generation\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Step 3: Train/Test Split\ntrain_mask = X.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X[train_mask]\ny_train = y[train_mask]\nX_test = X[test_mask]\ny_test = y[test_mask]\n\n# Step 4: Model Training\nmodel = LGBMRegressor(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=42)\nmodel.fit(X_train, y_train)\n\n# Step 5: Prediction and Position Construction\ny_pred = model.predict(X_test)\ndf_y = FinlabDataFrame(y_pred, index=X_test.index).unstack().T\n\n# Step 6: Create Trading Position\nposition = df_y.is_largest(10)  # Select top 10 stocks\n\n# Step 7: Backtest\nreport = sim(position)\nprint(report.get_metrics())\n```\n\n---\n\n### Advanced Feature Selection Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom lightgbm import LGBMRegressor\nfrom sklearn.feature_selection import SelectKBest, f_regression\nimport pandas as pd\n\n# Generate many features\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:股價淨值比'),\n    'pe': data.get('price_earning_ratio:本益比'),\n    'ps': data.get('price_earning_ratio:股價淨值比') * data.get('fundamental_features:每股營業額'),\n    'rsi_14': data.indicator('RSI', timeperiod=14),\n    'rsi_28': data.indicator('RSI', timeperiod=28),\n    'macd': data.indicator('MACD')[0],  # MACD line\n    'revenue_growth': data.get('monthly_revenue:去年同月增減(%)'),\n    'revenue_ma3': data.get('monthly_revenue:當月營收').average(3),\n    'roe': data.get('fundamental_features:ROE稅後'),\n    'roa': data.get('fundamental_features:ROA綜合損益'),\n    'gross_margin': data.get('fundamental_features:營業毛利率'),\n    'debt_ratio': data.get('fundamental_features:負債比率'),\n}\n\n# Combine and clean\nsample_filter = data.get('price:成交股數') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Feature selection\nselector = SelectKBest(score_func=f_regression, k=6)\nX_selected = selector.fit_transform(X, y)\nselected_features = X.columns[selector.get_support()].tolist()\n\nprint(\"Selected Features:\", selected_features)\n\n# Train model with selected features\nX_selected_df = pd.DataFrame(X_selected, index=X.index, columns=selected_features)\n\n# Split\ntrain_mask = X_selected_df.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X_selected_df.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X_selected_df[train_mask]\ny_train = y[train_mask]\nX_test = X_selected_df[test_mask]\n\n# Train and predict\nmodel = LGBMRegressor(n_estimators=200, learning_rate=0.05, max_depth=6)\nmodel.fit(X_train, y_train)\ny_pred = model.predict(X_test)\n\n# Feature importance\nimportance_df = pd.DataFrame({\n    'feature': selected_features,\n    'importance': model.feature_importances_\n}).sort_values('importance', ascending=False)\n\nprint(\"\\nFeature Importance:\")\nprint(importance_df)\n```\n\n---\n\n### Classification Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom finlab.dataframe import FinlabDataFrame\nfrom finlab.backtest import sim\nfrom lightgbm import LGBMClassifier\nimport pandas as pd\n\n# Feature engineering\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:股價淨值比'),\n    'rsi': data.indicator('RSI'),\n    'revenue_growth': data.get('monthly_revenue:去年同月增減(%)'),\n}\n\nsample_filter = data.get('price:成交股數') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\n\n# Binary classification label (outperform market or not)\ny_continuous = label.excess_over_mean(X.index, resample='M', period=1)\ny = (y_continuous > 0).astype(int)  # 1 if outperforms, 0 otherwise\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Split\ntrain_mask = X.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X[train_mask]\ny_train = y[train_mask]\nX_test = X[test_mask]\n\n# Train classifier\nmodel = LGBMClassifier(n_estimators=100, learning_rate=0.1, max_depth=5)\nmodel.fit(X_train, y_train)\n\n# Predict probabilities\ny_pred_proba = model.predict_proba(X_test)[:, 1]  # Probability of class 1\ndf_y = FinlabDataFrame(y_pred_proba, index=X_test.index).unstack().T\n\n# Create position based on probability\nposition = df_y.is_largest(10)  # Top 10 highest probability\n\n# Backtest\nreport = sim(position)\nprint(report.get_metrics())\n```\n\n---\n\n### Time Series Cross-Validation\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom lightgbm import LGBMRegressor\nfrom sklearn.model_selection import TimeSeriesSplit\nimport pandas as pd\nimport numpy as np\n\n# Prepare features and labels\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:股價淨值比'),\n    'rsi': data.indicator('RSI'),\n}\n\nX = feature.combine(features_dict, resample='M')\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Get unique dates for time series split\ndates = X.index.get_level_values('datetime').unique().sort_values()\ndate_to_idx = {date: idx for idx, date in enumerate(dates)}\nX['date_idx'] = X.index.get_level_values('datetime').map(date_to_idx)\n\n# Time series cross-validation\ntscv = TimeSeriesSplit(n_splits=5)\nscores = []\n\nfor train_idx, val_idx in tscv.split(dates):\n    train_dates = dates[train_idx]\n    val_dates = dates[val_idx]\n\n    X_train = X[X['date_idx'].isin([date_to_idx[d] for d in train_dates])].drop('date_idx', axis=1)\n    y_train = y[X_train.index]\n    X_val = X[X['date_idx'].isin([date_to_idx[d] for d in val_dates])].drop('date_idx', axis=1)\n    y_val = y[X_val.index]\n\n    model = LGBMRegressor(n_estimators=100)\n    model.fit(X_train, y_train)\n    score = model.score(X_val, y_val)\n    scores.append(score)\n    print(f\"Fold R²: {score:.4f}\")\n\nprint(f\"\\nAverage R²: {np.mean(scores):.4f} (+/- {np.std(scores):.4f})\")\n```\n\n---\n\n## Best Practices\n\n### Feature Engineering\n1. **Start with static indicators** - Use `data.indicator()` instead of `feature.ta()` for reproducibility\n2. **Set appropriate resample frequency** - Use 'W', 'ME', 'QE', or `revenue.index` to control data density\n3. **Apply sample filters** - Filter low-volume or special-status stocks using `sample_filter`\n4. **Handle missing data** - Always check and handle NaN values before training\n5. **Normalize features** - Consider scaling features for better model performance\n6. **Ensure proper alignment** - `feature.combine` handles this automatically\n\n### Label Generation\n1. **Match resample frequency** - Ensure label `resample` matches feature `resample`\n2. **Use excess returns** - `excess_over_mean` or `excess_over_median` for better signal\n3. **Consider prediction horizon** - Match `period` to your trading frequency\n4. **Align indices** - Use `features.index` when generating labels\n\n### Model Training\n1. **Time-based splits** - Use `X.index.get_level_values('datetime') > '2020-01-01'` for proper train/test split\n2. **Avoid look-ahead bias** - Never use future information in features\n3. **Cross-validate** - Use time series cross-validation, not random splits\n4. **Tune hyperparameters** - Use validation set for hyperparameter optimization\n5. **Monitor overfitting** - Compare train and test performance regularly\n\n### Position Construction\n1. **Use FinlabDataFrame** - Convert predictions with `FinlabDataFrame(y_pred, index=X_test.index).unstack().T`\n2. **Limit positions** - Use `is_largest(n)` or `is_smallest(n)` for position sizing\n3. **Apply filters** - Combine ML predictions with fundamental or technical filters\n4. **Set stop-loss/take-profit** - Protect against large losses in backtesting\n\n### Backtesting\n1. **Use realistic assumptions** - Include transaction costs and slippage\n2. **Test out-of-sample** - Always backtest on unseen data\n3. **Monitor metrics** - Check Sharpe ratio, max drawdown, and win rate\n4. **Avoid overfitting** - Be wary of perfect backtest results\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Available data sources\n- [Factor Examples](factor-examples.md) - Factor-based strategies\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n- [Backtesting Reference](backtesting-reference.md) - Backtest ML strategies\n",
  "trading-reference": "# Trading & Order Execution Reference\n\n## Overview\n\nThis reference covers the complete workflow for executing trades from backtest results to live orders. The process involves:\n\n1. **Position Calculation**: Convert backtest results to share quantities\n2. **Broker Connection**: Configure and connect to your broker account\n3. **Order Execution**: Create, update, and manage orders via OrderExecutor\n\n---\n\n## Position Class\n\nThe `Position` class represents target holdings and provides methods for converting backtest results to executable positions.\n\n**Import:**\n```python\nfrom finlab.online.order_executor import Position\n```\n\n### Position.from_report()\n\nConvert a backtest report to tradeable positions.\n\n**Signature:**\n```python\nPosition.from_report(\n    report,\n    fund: float,\n    odd_lot: bool = False\n) -> Position\n```\n\n**Parameters:**\n- `report` (Report, required): Backtest report object from `sim()`\n- `fund` (float, required): Total capital in TWD for position sizing\n- `odd_lot` (bool, default=False): Enable odd lot (零股) trading for smaller positions\n\n**Returns:**\n- `Position`: List of position dictionaries with stock_id, quantity, and order_condition\n\n**Example:**\n```python\nfrom finlab import backtest\nfrom finlab.online.order_executor import Position\n\nreport = backtest.sim(position, resample=\"M\")\n\n# Standard lot trading\nposition = Position.from_report(report, fund=1000000)\nprint(position)\n# [{'stock_id': '2330', 'quantity': 1, 'order_condition': <OrderCondition.CASH: 1>}]\n\n# Odd lot trading (smaller positions)\nposition = Position.from_report(report, fund=1000000, odd_lot=True)\n```\n\n---\n\n### Custom Position\n\nCreate a position manually without backtest.\n\n**Signature:**\n```python\nPosition(holdings: dict) -> Position\n```\n\n**Example:**\n```python\n# Simple position with share counts\nposition = Position({'2330': 1, '1101': 2})\n\n# Fractional shares (for odd lot)\nposition = Position({'2330': 1, '1101': 1.001})\n```\n\n---\n\n### Position Arithmetic\n\nCombine or modify positions using arithmetic operations.\n\n**Subtraction:**\n```python\n# Remove stocks from position\nnew_position = position - Position({'2330': 1})\n```\n\n**Addition:**\n```python\n# Add stocks to position\nnew_position = position + Position({'1101': 1})\n```\n\n**Multi-strategy combination:**\n```python\n# Combine positions from multiple strategies\nposition1 = Position.from_report(report1, fund=500000)\nposition2 = Position.from_report(report2, fund=500000)\ntotal_position = position1 + position2\n```\n\n---\n\n## Broker Account Setup\n\n### Environment Variables Summary\n\n| Broker | Required Environment Variables |\n|--------|-------------------------------|\n| Esun (玉山) | `ESUN_CONFIG_PATH`, `ESUN_MARKET_API_KEY`, `ESUN_ACCOUNT_PASSWORD`, `ESUN_CERT_PASSWORD` |\n| Sinopac (永豐) | `SHIOAJI_API_KEY`, `SHIOAJI_SECRET_KEY`, `SHIOAJI_CERT_PERSON_ID`, `SHIOAJI_CERT_PATH`, `SHIOAJI_CERT_PASSWORD` |\n| Masterlink (元富) | `MASTERLINK_NATIONAL_ID`, `MASTERLINK_ACCOUNT`, `MASTERLINK_ACCOUNT_PASS`, `MASTERLINK_CERT_PATH`, `MASTERLINK_CERT_PASS` |\n| Fubon (富邦) | `FUBON_NATIONAL_ID`, `FUBON_ACCOUNT_PASS`, `FUBON_CERT_PATH` |\n\n---\n\n### Esun (玉山證券)\n\n**Import:**\n```python\nfrom finlab.online.esun_account import EsunAccount\n```\n\n**Environment Variables:**\n```bash\nexport ESUN_CONFIG_PATH='/path/to/config.ini'\nexport ESUN_MARKET_API_KEY='your_market_api_key'\nexport ESUN_ACCOUNT_PASSWORD='your_password'\nexport ESUN_CERT_PASSWORD='your_cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['ESUN_CONFIG_PATH'] = '/path/to/config.ini'\nos.environ['ESUN_MARKET_API_KEY'] = 'your_market_api_key'\nos.environ['ESUN_ACCOUNT_PASSWORD'] = 'your_password'\nos.environ['ESUN_CERT_PASSWORD'] = 'your_cert_password'\n\nacc = EsunAccount()\n```\n\n**Install SDK:**\n```bash\npip install esun-trade\n```\n\n---\n\n### Sinopac (永豐證券)\n\n**Import:**\n```python\nfrom finlab.online.sinopac_account import SinopacAccount\n```\n\n**Environment Variables:**\n```bash\nexport SHIOAJI_API_KEY='api_key'\nexport SHIOAJI_SECRET_KEY='secret_key'\nexport SHIOAJI_CERT_PERSON_ID='A123456789'\nexport SHIOAJI_CERT_PATH='/path/to/cert'\nexport SHIOAJI_CERT_PASSWORD='cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['SHIOAJI_API_KEY'] = 'api_key'\nos.environ['SHIOAJI_SECRET_KEY'] = 'secret_key'\nos.environ['SHIOAJI_CERT_PERSON_ID'] = 'A123456789'\nos.environ['SHIOAJI_CERT_PATH'] = '/path/to/cert'\nos.environ['SHIOAJI_CERT_PASSWORD'] = 'cert_password'\n\nacc = SinopacAccount()\n```\n\n**Install SDK:**\n```bash\npip install shioaji\n```\n\n---\n\n### Masterlink (元富證券)\n\n**Import:**\n```python\nfrom finlab.online.masterlink_account import MasterlinkAccount\n```\n\n**Environment Variables:**\n```bash\nexport MASTERLINK_NATIONAL_ID='A123456789'\nexport MASTERLINK_ACCOUNT='account'\nexport MASTERLINK_ACCOUNT_PASS='password'\nexport MASTERLINK_CERT_PATH='/path/to/cert'\nexport MASTERLINK_CERT_PASS='cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['MASTERLINK_NATIONAL_ID'] = 'A123456789'\nos.environ['MASTERLINK_ACCOUNT'] = 'account'\nos.environ['MASTERLINK_ACCOUNT_PASS'] = 'password'\nos.environ['MASTERLINK_CERT_PATH'] = '/path/to/cert'\nos.environ['MASTERLINK_CERT_PASS'] = 'cert_password'\n\nacc = MasterlinkAccount()\n```\n\n---\n\n### Fubon (富邦證券)\n\n**Import:**\n```python\nfrom finlab.online.fubon_account import FubonAccount\n```\n\n**Environment Variables:**\n```bash\nexport FUBON_NATIONAL_ID='A123456789'\nexport FUBON_ACCOUNT_PASS='password'\nexport FUBON_CERT_PATH='/path/to/cert.pfx'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['FUBON_NATIONAL_ID'] = 'A123456789'\nos.environ['FUBON_ACCOUNT_PASS'] = 'password'\nos.environ['FUBON_CERT_PATH'] = '/path/to/cert.pfx'\n\nacc = FubonAccount()\n```\n\n---\n\n## OrderExecutor Class\n\nThe `OrderExecutor` manages order creation, modification, and cancellation.\n\n**Import:**\n```python\nfrom finlab.online.order_executor import OrderExecutor\n```\n\n**Signature:**\n```python\nOrderExecutor(\n    position: Position,\n    account: BrokerAccount\n) -> OrderExecutor\n```\n\n**Parameters:**\n- `position` (Position, required): Target position to execute\n- `account` (BrokerAccount, required): Connected broker account instance\n\n**Example:**\n```python\nfrom finlab.online.order_executor import OrderExecutor, Position\nfrom finlab.online.sinopac_account import SinopacAccount\n\n# Setup\nposition = Position.from_report(report, fund=1000000)\nacc = SinopacAccount()\nexecutor = OrderExecutor(position, account=acc)\n```\n\n---\n\n### OrderExecutor Methods\n\n#### show_alerting_stocks()\n\nDisplay stocks that require pre-deposit (處置股/警示股).\n\n```python\nexecutor.show_alerting_stocks()\n```\n\n---\n\n#### create_orders()\n\nCreate orders based on the target position.\n\n**Signature:**\n```python\ncreate_orders(view_only: bool = False) -> None\n```\n\n**Parameters:**\n- `view_only` (bool, default=False): If True, preview orders without execution\n\n**Example:**\n```python\n# Preview orders first (recommended)\nexecutor.create_orders(view_only=True)\n\n# Execute orders\nexecutor.create_orders()\n```\n\n---\n\n#### update_order_price()\n\nUpdate limit price for pending orders.\n\n```python\nexecutor.update_order_price()\n```\n\n---\n\n#### cancel_orders()\n\nCancel all pending orders.\n\n```python\nexecutor.cancel_orders()\n```\n\n---\n\n## Check Account Position\n\nQuery current holdings from broker.\n\n```python\n# Get current holdings\nprint(acc.get_position())\n```\n\n---\n\n## Related References\n\n- [backtesting-reference.md](backtesting-reference.md): Backtest configuration and report generation\n- [best-practices.md](best-practices.md): Coding patterns and anti-patterns\n"
}


def search_in_docs(query: str) -> list[dict]:
    """Search for a keyword in all documentation."""
    results = []
    query_lower = query.lower()

    for name, content in DOCS.items():
        if query_lower not in content.lower():
            continue

        lines = content.split("\n")
        for i, line in enumerate(lines):
            if query_lower in line.lower():
                start = max(0, i - 2)
                end = min(len(lines), i + 6)
                context = "\n".join(lines[start:end])
                results.append({
                    "file": name,
                    "line": i + 1,
                    "match": context
                })

    return results[:10]


@mcp.tool()
def list_documents() -> str:
    """List all available FinLab documentation files."""
    docs_list = []
    for name, content in sorted(DOCS.items()):
        first_line = ""
        for line in content.split("\n"):
            if line.strip():
                first_line = line.strip("# ").strip()
                break
        docs_list.append(f"- **{name}**: {first_line}")

    return "## Available FinLab Documents\n\n" + "\n".join(docs_list)


@mcp.tool()
def get_document(doc_name: str) -> str:
    """Get the full content of a FinLab documentation file.

    Args:
        doc_name: Name of the document (without .md extension).
                  Available: data-reference, backtesting-reference, dataframe-reference,
                  factor-examples, factor-analysis-reference, trading-reference,
                  best-practices, machine-learning-reference
    """
    if doc_name in DOCS:
        return DOCS[doc_name]

    available = ", ".join(sorted(DOCS.keys()))
    return f"Document '{doc_name}' not found.\n\nAvailable documents: {available}"


@mcp.tool()
def search_finlab_docs(query: str) -> str:
    """Search for a keyword or phrase in all FinLab documentation.

    Args:
        query: The search term to look for (case-insensitive)
    """
    results = search_in_docs(query)

    if not results:
        return f"No results found for '{query}'"

    output = f"## Search Results: {query}\n\n"
    for r in results:
        output += f"### {r['file']} (line {r['line']})\n"
        output += f"```\n{r['match']}\n```\n\n"

    return output


@mcp.tool()
def get_factor_examples(factor_type: str = "all") -> str:
    """Get factor/strategy examples from the documentation.

    Args:
        factor_type: Type of factor to filter by. Options:
                     - "all": All examples
                     - "value": Value investing factors
                     - "momentum": Price momentum strategies
                     - "technical": Technical analysis indicators
                     - "quality": Quality factors
                     - "ml": Machine learning strategies
    """
    if "factor-examples" not in DOCS:
        return "factor-examples not found"

    content = DOCS["factor-examples"]

    if factor_type == "all":
        return content

    factor_type_lower = factor_type.lower()
    sections = content.split("\n## ")

    matching_sections = []
    for section in sections:
        if factor_type_lower in section.lower():
            matching_sections.append("## " + section)

    if not matching_sections:
        return f"No examples found for factor type '{factor_type}'. Try: value, momentum, technical, quality, ml"

    return "\n\n".join(matching_sections)


# Create the Streamable HTTP app for Cloudflare Workers
app = mcp.streamable_http_app()
